<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Spread-Map Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #2c3e50;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #gridCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #gridCanvas:active {
            cursor: grabbing;
        }
        
        .zoom-controls {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .zoom-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-label {
            flex: 1;
            text-align: center;
            font-size: 11px;
            color: #aaa;
        }
        
        .container {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 260px;
            padding: 10px;
            z-index: 1000;
            color: white;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        
        .container::-webkit-scrollbar {
            width: 6px;
        }
        
        .container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        h1 {
            color: #fff;
            margin-bottom: 3px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 300;
        }
        
        .subtitle {
            color: #aaa;
            margin-bottom: 8px;
            font-size: 10px;
        }
        
        .form-group {
            margin-bottom: 8px;
        }
        
        label {
            display: block;
            color: #ccc;
            font-weight: 400;
            margin-bottom: 3px;
            font-size: 10px;
        }
        
        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .input-wrapper {
            display: flex;
            flex-direction: column;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 5px 6px;
            border: 1px solid #444;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .help-text {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        
        .preview-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 6px 8px;
            margin: 6px 0;
        }
        
        .preview-title {
            font-weight: 400;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .preview-info {
            color: #ccc;
            font-size: 10px;
            line-height: 1.5;
        }
        
        .preview-info div {
            margin: 3px 0;
        }
        
        .preview-info strong {
            color: #aaa;
            font-weight: 400;
            display: inline-block;
            min-width: 60px;
        }
        
        .preview-value {
            color: #667eea;
            font-weight: 600;
        }
        
        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
        }
        
        button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #667eea;
            color: white;
        }
        
        button:hover {
            background: #5568d3;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 12px;
            color: #667eea;
            font-size: 11px;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 6px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid rgba(255, 50, 50, 0.5);
            color: #ff8888;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            display: none;
            font-size: 11px;
        }
        
        .error.show {
            display: block;
        }
        
        /* Scrollbar styling for dark theme */
        .container::-webkit-scrollbar {
            width: 6px;
        }
        
        .container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .section-title {
            font-size: 10px;
            font-weight: 400;
            color: #aaa;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .slider-row input[type="range"] {
            flex: 1;
        }
        
        .reset-btn {
            padding: 4px 8px;
            font-size: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gridCanvas"></canvas>
    
    <div class="container">
        <h1>üåå Spread-Map</h1>
        <p class="subtitle">Generate custom spreadsheet maps</p>
        
        <form id="mapForm">
            <div class="section-title">Universe Dimensions</div>
            <div class="form-group">
                <div class="input-row">
                    <div class="input-wrapper">
                        <label>Columns</label>
                        <input type="number" id="cols" name="cols" value="20" min="1" max="50" required>
                        <div class="help-text">1-20 left to right</div>
                    </div>
                    <div class="input-wrapper">
                        <label>Rows</label>
                        <input type="number" id="rows" name="rows" value="10" min="1" max="50" required>
                        <div class="help-text">B1, B2, B3...</div>
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="section-title">Grid Layout</div>
            <div class="form-group">
                <div class="input-row">
                    <div class="input-wrapper">
                        <label>Horizontal</label>
                        <input type="number" id="universes_h" name="universes_h" value="6" min="1" max="20" required>
                        <div class="help-text">universes</div>
                    </div>
                    <div class="input-wrapper">
                        <label>Vertical</label>
                        <input type="number" id="universes_v" name="universes_v" value="5" min="1" max="20" required>
                        <div class="help-text">universes</div>
                    </div>
                </div>
            </div>
            
            <button type="button" id="applyGridBtn" style="width: 100%; margin-top: 8px; padding: 6px; background: #667eea; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; font-weight: 500;">
                Apply Grid Changes
            </button>
            
            <div class="preview-box" id="previewBox">
                <div class="preview-title">üìä Stats</div>
                <div class="preview-info" id="previewInfo">
                    <div><strong>Universes:</strong> <span class="preview-value" id="totalUniverses">-</span></div>
                    <div><strong>Grid:</strong> <span class="preview-value" id="gridSize">-</span></div>
                    <div><strong>Cells per Universe:</strong> <span class="preview-value" id="cellsPerUniverse">-</span></div>
                    <div><strong>Total Cells:</strong> <span class="preview-value" id="totalCells">-</span></div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="section-title">Display Options</div>
            <div class="form-group">
                <div class="input-wrapper" style="width: 100%;">
                    <label style="display: block;">Spread-Map Alpha: <span id="mapAlphaValue">100%</span></label>
                    <input type="range" id="mapAlpha" min="0" max="100" step="1" value="100" style="width: 100%;">
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label>
                        <input type="checkbox" id="showCableGroups" checked>
                        Show Cable Groups (20)
                    </label>
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label>
                        <input type="checkbox" id="showPointCloud" checked>
                        Show Points
                    </label>
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label>
                        <input type="checkbox" id="showRowColHeaders" checked>
                        Show Row/Column Headers
                    </label>
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label>
                        <input type="checkbox" id="showCrosshair">
                        Show Crosshair
                    </label>
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 12px;">
                    <label style="display: block; margin-bottom: 4px;">Load Spreadsheet:</label>
                    <input type="file" id="csvFileInput" accept=".csv,.xlsx" style="font-size: 11px; width: 100%;">
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label style="display: block;">Point Scale: <span id="pointScaleValue">1.0x</span></label>
                    <div class="slider-row">
                        <input type="range" id="pointScale" min="0.01" max="10" step="0.01" value="1">
                        <button type="button" class="reset-btn" id="resetPointScale" title="Reset to auto-detected pitch">‚Üª</button>
                    </div>
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label style="display: block;">Point Size: <span id="pointSizeValue">20px</span></label>
                    <input type="range" id="pointSize" min="1" max="20" step="1" value="20" style="width: 100%;">
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label style="display: block;">Point Offset X: <span id="pointOffsetXValue">0</span></label>
                    <input type="range" id="pointOffsetX" min="-500" max="500" step="1" value="0" style="width: 100%;">
                </div>
                <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                    <label style="display: block;">Point Offset Y: <span id="pointOffsetYValue">0</span></label>
                    <input type="range" id="pointOffsetY" min="-500" max="500" step="1" value="0" style="width: 100%;">
                </div>
            </div>

            <div class="divider"></div>
            
            <div class="section-title">View Controls</div>
            <div class="zoom-controls">
                <button type="button" class="zoom-btn" id="zoomOut">‚àí</button>
                <div class="zoom-label" id="zoomLevel">100%</div>
                <button type="button" class="zoom-btn" id="zoomIn">+</button>
            </div>
            <div style="font-size: 10px; color: #888; text-align: center; margin-top: 4px;">
                Scroll to zoom ‚Ä¢ Drag to pan<br>
                Double-click cell to edit B number
            </div>
            
            <div class="divider"></div>
            
            <button type="submit">
                ‚¨áÔ∏è Generate & Download Excel
            </button>
            
            <div class="error" id="errorBox"></div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Generating Excel file...</div>
            </div>
            
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); text-align: center;">
                <a href="https://github.com/stephanschulz/spread-map" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="flex-shrink: 0;">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    GitHub Repository
                </a>
            </div>
        </form>
    </div>
    
    <script>
        // Global state for zoom and pan
        let zoom = 0.8;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Global mouse position for crosshair
        let currentMouseX = -1;
        let currentMouseY = -1;
        
        // Cache for pre-rendered grid image
        let cachedGridImage = null;
        let cachedGridConfig = null;
        
        // Point cloud data
        let pointCloudData = [];
        let pointCloudLoaded = false;
        let pointCloudBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let pointCloudPitch = { x: 0, y: 0 }; // Detected pitch/spacing
        let cableGroups = []; // Groups of 20 points with their center points
        let cellToBoxNumber = new Map(); // Maps "row,col" to box number

        // Variable universe grid structure - each universe has independent dimensions
        let universeGrid = {
            universesH: 6,
            universesV: 5,
            // 2D array of universes: universes[uRow][uCol] = {cols, rows}
            universes: [],
            showCellText: true // Show text on initial load
        };

        // Dragging state for boundaries
        let draggingBoundary = null;
        let dragStartX = 0;
        let dragStartY = 0;

        // Initialize universe grid with uniform dimensions
        function initializeUniverseGrid(cols, rows, universesH, universesV) {
            universeGrid.universesH = universesH;
            universeGrid.universesV = universesV;
            universeGrid.universes = [];

            // Initialize each universe with independent dimensions
            for (let uRow = 0; uRow < universesV; uRow++) {
                const rowArray = [];
                for (let uCol = 0; uCol < universesH; uCol++) {
                    rowArray.push({
                        cols: cols,
                        rows: rows
                    });
                }
                universeGrid.universes.push(rowArray);
            }

            console.log('Initialized universe grid:', universeGrid);
        }

        // Get universe at specific position
        function getUniverse(uRow, uCol) {
            if (uRow >= 0 && uRow < universeGrid.universesV &&
                uCol >= 0 && uCol < universeGrid.universesH) {
                return universeGrid.universes[uRow][uCol];
            }
            return null;
        }

        // Get total columns for a specific universe
        function getUniverseCols(uRow, uCol) {
            const uni = getUniverse(uRow, uCol);
            return uni ? uni.cols : 0;
        }

        // Get total rows for a specific universe
        function getUniverseRows(uRow, uCol) {
            const uni = getUniverse(uRow, uCol);
            return uni ? uni.rows : 0;
        }

        // Get total columns across all universes (max in any row)
        function getTotalCols() {
            let maxCols = 0;
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                let rowCols = 0;
                for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                    rowCols += getUniverseCols(uRow, uCol);
                }
                maxCols = Math.max(maxCols, rowCols);
            }
            return maxCols;
        }

        // Get total rows across all universes (max in any column)
        function getTotalRows() {
            let maxRows = 0;
            for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                let colRows = 0;
                for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                    colRows += getUniverseRows(uRow, uCol);
                }
                maxRows = Math.max(maxRows, colRows);
            }
            return maxRows;
        }

        // Read and parse Excel file
        function parseExcelFile(arrayBuffer) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array', cellStyles: true });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                return { workbook, worksheet };
            } catch (error) {
                console.error('Error parsing Excel file:', error);
                throw new Error('Failed to parse Excel file');
            }
        }

        // Detect if file is a point cloud CSV or exported map
        function detectFileFormat(data, isExcel) {
            if (isExcel) {
                // For Excel, check the header row
                const { worksheet } = data;
                const range = XLSX.utils.decode_range(worksheet['!ref']);
                
                // Check first row for column headers
                let hasColumnHeaders = false;
                let hasPointCloudHeaders = false;
                
                for (let C = range.s.c; C <= Math.min(range.s.c + 5, range.e.c); C++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: 0, c: C });
                    const cell = worksheet[cellAddress];
                    if (cell && cell.v) {
                        const value = String(cell.v).trim();
                        if (value.match(/^C\d+$/)) {
                            hasColumnHeaders = true;
                        }
                        if (value === 'ID' || value === 'px' || value === 'py') {
                            hasPointCloudHeaders = true;
                        }
                    }
                }
                
                return hasColumnHeaders ? 'exported-map' : (hasPointCloudHeaders ? 'point-cloud' : 'unknown');
            } else {
                // For CSV, check the first line
                const firstLine = data.trim().split('\n')[0];
                if (firstLine.includes('ID,px,py') || firstLine.includes('ID,') && firstLine.includes(',px,') && firstLine.includes(',py,')) {
                    return 'point-cloud';
                }
                if (firstLine.match(/C\d+/)) {
                    return 'exported-map';
                }
                return 'unknown';
            }
        }

        // Import exported map - reconstruct grid and points
        function importExportedMap(mapData) {
            console.log('Importing exported map:', mapData);
            
            // Update form inputs
            const avgCols = Math.round(mapData.universes[0].reduce((sum, u) => sum + u.cols, 0) / mapData.universesH);
            const avgRows = Math.round(mapData.universes.reduce((sum, row) => sum + row[0].rows, 0) / mapData.universesV);
            
            document.getElementById('cols').value = avgCols;
            document.getElementById('rows').value = avgRows;
            document.getElementById('universes_h').value = mapData.universesH;
            document.getElementById('universes_v').value = mapData.universesV;
            
            // Rebuild universe grid
            universeGrid.universesH = mapData.universesH;
            universeGrid.universesV = mapData.universesV;
            universeGrid.universes = mapData.universes;
            universeGrid.showCellText = true; // Show cell text since this is an imported map
            
            // Import custom cell data if available
            if (mapData.customCellData) {
                cellCustomData.clear();
                mapData.customCellData.forEach((value, key) => {
                    cellCustomData.set(key, value);
                });
                console.log('Imported', cellCustomData.size, 'cells with custom data');
            }
            
            console.log('Universe grid rebuilt:', universeGrid);
            
            // Convert point positions to point cloud data
            pointCloudData = [];
            const baseCellSize = 60;
            
            if (mapData.points.length > 0) {
                // Calculate cell positions and convert to coordinates
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                // Need to flip Y because Excel row 1 is at top, but our coordinate system has Y increasing upward
                const totalRows = mapData.totalRows;
                
                // Group points by Y position to detect stagger pattern
                const pointsByY = new Map();
                mapData.points.forEach(point => {
                    const flippedGridRow = totalRows - 1 - point.gridRow;
                    if (!pointsByY.has(flippedGridRow)) {
                        pointsByY.set(flippedGridRow, []);
                    }
                    pointsByY.get(flippedGridRow).push(point);
                });
                
                // Detect if there's a consistent stagger pattern and what the offset should be
                let detectedStaggerOffset = 0;
                const yRows = Array.from(pointsByY.keys()).sort((a, b) => a - b);
                
                // Check if alternate rows have left/right stagger pattern
                if (yRows.length >= 2) {
                    // Sample first row to determine base pattern
                    const firstRowPoints = pointsByY.get(yRows[0]);
                    const hasLeftStagger = firstRowPoints.some(p => p.leftStagger);
                    
                    // Set stagger offset (in cell fraction) based on pattern
                    // Left stagger (even rows) = no offset, Right stagger (odd rows) = 0.5 cell offset
                    detectedStaggerOffset = hasLeftStagger ? 0 : 0.5;
                    console.log('Detected stagger offset:', detectedStaggerOffset, 'hasLeftStagger:', hasLeftStagger);
                }
                
                mapData.points.forEach(point => {
                    // Convert grid position to pixel coordinates
                    // Each cell is baseCellSize pixels
                    
                    // Flip Y coordinate: Excel row 0 (after header) should be at bottom of our grid
                    const flippedGridRow = totalRows - 1 - point.gridRow;
                    const pixelY = flippedGridRow * baseCellSize + baseCellSize / 2;
                    
                    // Apply stagger offset based on left/right indicator
                    // leftStagger = true means even row (no X offset)
                    // leftStagger = false means odd row (X offset by 0.5 cells)
                    const xOffset = point.leftStagger ? 0 : 0.5;
                    const pixelX = (point.gridCol + xOffset) * baseCellSize + baseCellSize / 2;
                    
                    pointCloudData.push({ x: pixelX / baseCellSize, y: pixelY / baseCellSize });
                    
                    minX = Math.min(minX, pixelX / baseCellSize);
                    maxX = Math.max(maxX, pixelX / baseCellSize);
                    minY = Math.min(minY, pixelY / baseCellSize);
                    maxY = Math.max(maxY, pixelY / baseCellSize);
                });
                
                pointCloudBounds = { minX, maxX, minY, maxY };
                
                // Detect pitch from imported points
                const uniqueY = [...new Set(pointCloudData.map(p => p.y))].sort((a, b) => a - b);
                let minYDiff = Infinity;
                for (let i = 1; i < uniqueY.length; i++) {
                    const diff = uniqueY[i] - uniqueY[i - 1];
                    if (diff > 0.001) {
                        minYDiff = Math.min(minYDiff, diff);
                    }
                }
                pointCloudPitch.y = minYDiff;
                
                const uniqueX = [...new Set(pointCloudData.map(p => p.x))].sort((a, b) => a - b);
                let minXDiff = Infinity;
                for (let i = 1; i < uniqueX.length; i++) {
                    const diff = uniqueX[i] - uniqueX[i - 1];
                    if (diff > 0.001) {
                        minXDiff = Math.min(minXDiff, diff);
                    }
                }
                pointCloudPitch.x = minXDiff;
                
                pointCloudLoaded = true;
                
                // Set point scale to 1 since we're importing from the same coordinate system
                document.getElementById('pointScale').value = 1.0;
                document.getElementById('pointScaleValue').textContent = '1.0x';
                
                // Reset offsets
                document.getElementById('pointOffsetX').value = 0;
                document.getElementById('pointOffsetY').value = 0;
                document.getElementById('pointOffsetXValue').textContent = '0';
                document.getElementById('pointOffsetYValue').textContent = '0';
                
                // Calculate cable groups
                calculateCableGroups();
                
                console.log('Imported', pointCloudData.length, 'points');
            } else {
                pointCloudLoaded = false;
                pointCloudData = [];
                console.log('No points found in imported map');
            }
            
            // Update preview
            updatePreview();
            saveSettings();
        }

        // Parse exported map structure from Excel file
        function parseExportedMap(worksheet) {
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            console.log('Parsing exported map, range:', range);
            
            // Count columns (C1, C2, C3...)
            const totalCols = range.e.c; // 0-based, so actual count is this value
            
            // Count rows (R1, R2, R3...)
            const totalRows = range.e.r; // 0-based, so actual count is this value
            
            console.log('Grid dimensions:', totalCols, 'cols x', totalRows, 'rows');
            
            // Map to store universe info: universeNum -> {cells: [{row, col, hasPoint, pointLeft}], minRow, maxRow, minCol, maxCol}
            const universeMap = new Map();
            const customCellData = new Map(); // key: "row,col", value: {index, universe, box, note}
            
            // Parse all data cells (skip header row and column)
            for (let R = 1; R <= range.e.r; R++) {
                for (let C = 1; C <= range.e.c; C++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                    const cell = worksheet[cellAddress];
                    
                    if (cell && cell.v) {
                        const cellText = String(cell.v);
                        const lines = cellText.split('\n');
                        
                        // Parse custom cell data if using new format
                        const parsedData = parseCellContent(cellText);
                        if (parsedData.index || parsedData.universe || parsedData.box || parsedData.note) {
                            const cellKey = `${R - 1},${C - 1}`; // Convert to 0-based
                            customCellData.set(cellKey, parsedData);
                        }
                        
                        // Look for universe number (e.g., "U3-B2")
                        let universeNum = null;
                        let hasPoint = cellText.includes('‚óè');
                        let pointLeft = false;
                        
                        for (const line of lines) {
                            const universeMatch = line.match(/U(\d+)/);
                            if (universeMatch) {
                                universeNum = parseInt(universeMatch[1]);
                                break;
                            }
                        }
                        
                        // Check if point is on left or right
                        if (hasPoint && lines.length > 0) {
                            pointLeft = lines[0].trim().startsWith('‚óè');
                        }
                        
                        if (universeNum) {
                            if (!universeMap.has(universeNum)) {
                                universeMap.set(universeNum, {
                                    cells: [],
                                    minRow: R,
                                    maxRow: R,
                                    minCol: C,
                                    maxCol: C
                                });
                            }
                            
                            const uniData = universeMap.get(universeNum);
                            uniData.cells.push({ row: R, col: C, hasPoint, pointLeft });
                            uniData.minRow = Math.min(uniData.minRow, R);
                            uniData.maxRow = Math.max(uniData.maxRow, R);
                            uniData.minCol = Math.min(uniData.minCol, C);
                            uniData.maxCol = Math.max(uniData.maxCol, C);
                        }
                    }
                }
            }
            
            console.log('Found', universeMap.size, 'universes');
            
            // Determine universe grid layout
            // Find max universe number to determine total count
            const maxUniverseNum = Math.max(...Array.from(universeMap.keys()));
            
            // Calculate grid dimensions for universes
            // We need to determine universesH and universesV from the layout
            // Strategy: find the universe positions and infer the grid
            
            // Get position of each universe (top-left corner)
            const universePositions = new Map();
            universeMap.forEach((data, num) => {
                universePositions.set(num, { row: data.minRow, col: data.minCol });
            });
            
            // Find unique row and column positions
            const uniqueRows = [...new Set(Array.from(universePositions.values()).map(p => p.row))].sort((a, b) => a - b);
            const uniqueCols = [...new Set(Array.from(universePositions.values()).map(p => p.col))].sort((a, b) => a - b);
            
            const universesV = uniqueRows.length;
            const universesH = uniqueCols.length;
            
            console.log('Universe grid:', universesH, 'x', universesV);
            
            // Build universe grid structure
            const universes = [];
            for (let uRow = 0; uRow < universesV; uRow++) {
                const rowArray = [];
                for (let uCol = 0; uCol < universesH; uCol++) {
                    // Find which universe is at this position
                    const targetRow = uniqueRows[uRow];
                    const targetCol = uniqueCols[uCol];
                    
                    let foundUniverse = null;
                    universeMap.forEach((data, num) => {
                        if (data.minRow === targetRow && data.minCol === targetCol) {
                            foundUniverse = { num, data };
                        }
                    });
                    
                    if (foundUniverse) {
                        const cols = foundUniverse.data.maxCol - foundUniverse.data.minCol + 1;
                        const rows = foundUniverse.data.maxRow - foundUniverse.data.minRow + 1;
                        rowArray.push({ cols, rows });
                    } else {
                        // Shouldn't happen, but handle gracefully
                        rowArray.push({ cols: 20, rows: 10 });
                    }
                }
                universes.push(rowArray);
            }
            
            // Extract point locations
            const points = [];
            universeMap.forEach((data, num) => {
                data.cells.forEach(cell => {
                    if (cell.hasPoint) {
                        // Convert cell position (1-based in Excel) to 0-based grid position
                        points.push({
                            gridRow: cell.row - 1,  // -1 to account for header row
                            gridCol: cell.col - 1,  // -1 to account for header column
                            leftStagger: cell.pointLeft
                        });
                    }
                });
            });
            
            console.log('Extracted', points.length, 'points');
            
            return {
                universesH,
                universesV,
                universes,
                points,
                totalCols,
                totalRows,
                customCellData
            };
        }

        // Parse CSV text into point cloud data
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            
            // Skip header line
            pointCloudData = [];
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length >= 3) {
                    const x = parseFloat(parts[1]); // px column
                    const y = parseFloat(parts[2]); // py column
                    if (!isNaN(x) && !isNaN(y)) {
                        pointCloudData.push({ x, y });
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // Detect pitch (fixed spacing) in Y direction
            // Find unique Y values and calculate minimum non-zero difference
            const uniqueY = [...new Set(pointCloudData.map(p => p.y))].sort((a, b) => a - b);
            let minYDiff = Infinity;
            for (let i = 1; i < uniqueY.length; i++) {
                const diff = uniqueY[i] - uniqueY[i - 1];
                if (diff > 0.001) { // Ignore tiny differences (floating point errors)
                    minYDiff = Math.min(minYDiff, diff);
                }
            }
            pointCloudPitch.y = minYDiff;
            
            // Same for X direction
            const uniqueX = [...new Set(pointCloudData.map(p => p.x))].sort((a, b) => a - b);
            let minXDiff = Infinity;
            for (let i = 1; i < uniqueX.length; i++) {
                const diff = uniqueX[i] - uniqueX[i - 1];
                if (diff > 0.001) {
                    minXDiff = Math.min(minXDiff, diff);
                }
            }
            pointCloudPitch.x = minXDiff;
            
            // Store bounds for normalization
            pointCloudBounds = { minX, maxX, minY, maxY };
            pointCloudLoaded = true;
            
            console.log('Point cloud loaded:', pointCloudData.length, 'points');
            console.log('X range:', minX, 'to', maxX, '(width:', maxX - minX, ')');
            console.log('Y range:', minY, 'to', maxY, '(height:', maxY - minY, ')');
            console.log('Detected pitch - X:', pointCloudPitch.x.toFixed(3), 'Y:', pointCloudPitch.y.toFixed(3));
            
            // Calculate ideal point scale to match cell size
            // If pitch * baseCellSize * pointScale = baseCellSize, then pointScale = 1 / pitch
            const baseCellSize = 60;
            const idealScale = 1 / pointCloudPitch.y; // Use Y pitch as reference
            console.log('Ideal point scale to match cells:', idealScale.toFixed(3));
            
            // Auto-set the point scale if not already manually adjusted
            const currentScale = parseFloat(document.getElementById('pointScale').value);
            if (Math.abs(currentScale - 1.0) < 0.01) { // Only auto-adjust if still at default
                document.getElementById('pointScale').value = idealScale.toFixed(3);
                document.getElementById('pointScaleValue').textContent = idealScale.toFixed(2) + 'x';
                console.log('Auto-adjusted point scale to:', idealScale.toFixed(3));
            }

            // Calculate cable groups
            calculateCableGroups();
        }

        // Calculate cable groups - group by universe, 20 points per group, starting from top-right
        function calculateCableGroups() {
            cableGroups = [];
            // Preserve manual B number assignments
            const manualAssignments = new Map(cellToBoxNumber);
            cellToBoxNumber.clear(); // Clear for recalculation
            const groupSize = 20;

            // Get point transformation settings
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
            const baseCellSize = 60;
            const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;

            // Assign each point to a universe based on its cell position (variable grid)
            const pointsByUniverse = new Map();

            pointCloudData.forEach((point, idx) => {
                // All points (including created ones) now use x,y coordinates
                const relativeX = point.x - pointCloudBounds.minX;
                const relativeY = point.y - pointCloudBounds.minY;

                const gridPixelX = relativeX * baseCellSize * pointScale;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                // Convert to cell indices
                const cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                const cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);

                // Calculate universe from cell position using variable grid
                // Use same logic as drawDynamicGrid - calculate position independently per universe
                let universeCol = -1;
                let universeRow = -1;

                // Find which universe this cell belongs to
                for (let uRow = 0; uRow < universeGrid.universesV && universeRow < 0; uRow++) {
                    for (let uCol = 0; uCol < universeGrid.universesH && universeCol < 0; uCol++) {
                        // Calculate X position by summing widths in the SAME ROW
                        let currentX = 0;
                        for (let c = 0; c < uCol; c++) {
                            currentX += getUniverseCols(uRow, c);
                        }

                        // Calculate Y position by summing heights in the SAME COLUMN
                        let currentY = 0;
                        for (let r = 0; r < uRow; r++) {
                            currentY += getUniverseRows(r, uCol);
                        }

                        const colsInUniverse = getUniverseCols(uRow, uCol);
                        const rowsInUniverse = getUniverseRows(uRow, uCol);

                        if (cellCol >= currentX && cellCol < currentX + colsInUniverse &&
                            cellRow >= currentY && cellRow < currentY + rowsInUniverse) {
                            universeCol = uCol;
                            universeRow = uRow;
                            break;
                        }
                    }
                }

                if (universeCol >= 0 && universeRow >= 0) {
                    const universeNum = (universeRow * universeGrid.universesH) + universeCol + 1;

                    // Store point with its position info
                    if (!pointsByUniverse.has(universeNum)) {
                        pointsByUniverse.set(universeNum, []);
                    }

                    pointsByUniverse.get(universeNum).push({
                        point: point,
                        cellRow: cellRow,
                        cellCol: cellCol,
                        originalIndex: idx
                    });
                }
            });

            // Count total points assigned
            let totalAssignedPoints = 0;
            pointsByUniverse.forEach(points => {
                totalAssignedPoints += points.length;
            });

            console.log('Points distributed across', pointsByUniverse.size, 'universes');
            console.log('Total points assigned:', totalAssignedPoints, 'out of', pointCloudData.length);
            if (totalAssignedPoints < pointCloudData.length) {
                console.warn('Warning:', pointCloudData.length - totalAssignedPoints, 'points fell outside grid boundaries');
            }

            // Log manual assignments for debugging
            console.log('calculateCableGroups: manualAssignments has', manualAssignments.size, 'entries');
            manualAssignments.forEach((val, key) => {
                console.log(`  manualAssignment: ${key} -> ${val}`);
            });
            
            // For each universe, group points by B number (manual or automatic)
            pointsByUniverse.forEach((universePoints, universeNum) => {
                // First, check for manual B number assignments
                const pointsWithManualBox = [];
                const pointsWithoutBox = [];
                const pointsExplicitlyNoBox = []; // Points with explicitly empty B field
                
                universePoints.forEach(pointData => {
                    const key = `${pointData.cellRow},${pointData.cellCol}`;
                    const manualBoxNum = manualAssignments.get(key);
                    const customData = cellCustomData.get(key);
                    
                    // Debug log for each point
                    if (customData) {
                        console.log(`calculateCableGroups point: key=${key}, manualBoxNum=${manualBoxNum}, customData.box='${customData.box}'`);
                    }
                    
                    // Check if there's a manual box assignment first (takes priority)
                    if (manualBoxNum !== undefined) {
                        pointsWithManualBox.push({ ...pointData, boxNum: manualBoxNum });
                        // Restore the manual assignment
                        cellToBoxNumber.set(key, manualBoxNum);
                    } else if (customData && customData.box === '') {
                        // Explicitly no box (and no manual assignment) - don't assign to any group
                        pointsExplicitlyNoBox.push(pointData);
                    } else {
                        pointsWithoutBox.push(pointData);
                    }
                });
                
                // Group points with manual assignments by their box number
                const manualGroups = new Map();
                pointsWithManualBox.forEach(pointData => {
                    if (!manualGroups.has(pointData.boxNum)) {
                        manualGroups.set(pointData.boxNum, []);
                    }
                    manualGroups.get(pointData.boxNum).push(pointData);
                });
                
                // For points without manual assignments, sort and auto-group
                pointsWithoutBox.sort((a, b) => {
                    if (a.cellRow !== b.cellRow) {
                        return a.cellRow - b.cellRow; // Top rows first
                    }
                    return b.cellCol - a.cellCol; // Right columns first within same row
                });
                
                // Auto-assign box numbers to unassigned points
                let nextBoxNum = 1;
                // Find the highest manual box number to continue from
                if (manualGroups.size > 0) {
                    nextBoxNum = Math.max(...Array.from(manualGroups.keys())) + 1;
                }
                
                for (let i = 0; i < pointsWithoutBox.length; i += groupSize) {
                    const groupPointsData = pointsWithoutBox.slice(i, i + groupSize);
                    const boxNum = nextBoxNum;
                    nextBoxNum++;
                    
                    // Map each cell in this group to its box number
                    groupPointsData.forEach(pointData => {
                        const key = `${pointData.cellRow},${pointData.cellCol}`;
                        cellToBoxNumber.set(key, boxNum);
                    });
                    
                    // Add to manual groups for processing
                    if (!manualGroups.has(boxNum)) {
                        manualGroups.set(boxNum, []);
                    }
                    manualGroups.get(boxNum).push(...groupPointsData);
                }
                
                // Create cable groups from all groups (manual and auto)
                manualGroups.forEach((groupPointsData, boxNum) => {
                    const groupPoints = groupPointsData.map(p => p.point);
                    
                    // Calculate center point (green dot position) using CSV coordinates
                    let sumX = 0, sumY = 0;
                    groupPoints.forEach(point => {
                        sumX += point.x;
                        sumY += point.y;
                    });
                    
                    const centerX = sumX / groupPoints.length;
                    const centerY = sumY / groupPoints.length;
                    
                    cableGroups.push({
                        points: groupPoints,
                        center: { x: centerX, y: centerY },
                        universeNum: universeNum,
                        groupInUniverse: boxNum
                    });
                });
            });

            console.log('Calculated', cableGroups.length, 'cable groups of up to', groupSize, 'points each across', pointsByUniverse.size, 'universes');
        }
        
        // Load point cloud data from CSV file
        async function loadPointCloud() {
            try {
                const response = await fetch('layout.csv');
                const csvText = await response.text();
                parseCSV(csvText);
                updatePreview(); // Redraw with points
            } catch (error) {
                console.error('Failed to load point cloud:', error);
                pointCloudLoaded = false;
            }
        }
        
        // Generate universe colors
        function generateUniverseColors(totalUniverses) {
            const baseColors = [
                'FF6B6B', '4ECDC4', 'FFE66D', '95E1D3', 'FF8B94', 'A8E6CF',
                'FFD93D', '6BCF7F', 'FFA07A', '87CEEB', 'DDA15E', 'B4A7D6',
                'FFC0CB', '98D8C8', 'FFD700', '9370DB', 'FFA500', '20B2AA',
                'FF69B4', '7FFFD4', 'FFDAB9', '8FBC8F', 'FFC1CC', 'AFEEEE',
                'FFB6C1', '00CED1', 'FFA07A', '9ACD32', 'FF7F50', '48D1CC',
                'FFD700', '9932CC', 'FF8C00', '00FA9A', 'DA70D6', '32CD32',
            ];
            
            const colors = {};
            for (let i = 0; i < totalUniverses; i++) {
                colors[i + 1] = baseColors[i % baseColors.length];
            }
            return colors;
        }
        
        // Draw point cloud overlay
        function drawPointCloud(ctx, gridOffsetX, gridOffsetY, gridScale, pointScale, pointSize, pointOffsetX, pointOffsetY) {
            // Base cell size from the pre-rendered grid
            const baseCellSize = 60;
            
            // Calculate CSV data range
            const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;
            
            console.log('Point cloud rendering:', {
                csvBounds: pointCloudBounds,
                csvSize: { width: csvWidth, height: csvHeight },
                gridTransform: { offsetX: gridOffsetX, offsetY: gridOffsetY, scale: gridScale },
                pointAdjustments: { scale: pointScale, offsetX: pointOffsetX, offsetY: pointOffsetY }
            });
            
            ctx.save();
            
            let drawnCount = 0;
            let visibleCount = 0;
            
            // Draw each point
            pointCloudData.forEach((point, idx) => {
                // All points (including created ones) now use x,y coordinates
                const relativeX = point.x - pointCloudBounds.minX;
                const relativeY = point.y - pointCloudBounds.minY;
                
                // Convert to "grid pixel space" (as if in the high-res rendered image)
                // Scale to match cell size, apply point scale adjustment
                const gridPixelX = relativeX * baseCellSize * pointScale;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                
                // Flip Y coordinate
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                
                // Apply offsets in grid space (before scale so they zoom with the map)
                const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;
                
                // Convert to cell indices
                const cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                const cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);
                const cellKey = `${cellRow},${cellCol}`;
                
                // Check if this cell has explicitly empty B - if so, skip drawing the point
                const customData = cellCustomData.get(cellKey);
                const hasBoxNumber = cellToBoxNumber.has(cellKey);
                
                // Debug log for first few points
                if (idx < 5) {
                    console.log(`drawPointCloud point ${idx}: cellKey=${cellKey}, customData.box=${customData?.box}, hasBoxNumber=${hasBoxNumber}`);
                }
                
                // Don't draw if B is explicitly empty (in custom data) AND there's no box number assigned
                // If there's a box number, always draw (even if customData.box was previously empty)
                if (customData && customData.box === '' && !hasBoxNumber) {
                    // Cell has explicitly empty B and no box number - don't draw the point
                    return;
                }
                
                // If there's a box number, the point should be drawn (will be connected to green dot)
                
                // Apply grid's transformation (same as the spread-map image)
                // This makes points zoom/pan with the map
                const px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                const py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);
                
                // Check if point is visible on canvas
                const isVisible = px >= -50 && px <= ctx.canvas.width + 50 && 
                                  py >= -50 && py <= ctx.canvas.height + 50;
                if (isVisible) visibleCount++;
                
                // Draw point as a circle (scale size with grid zoom)
                const scaledPointSize = pointSize * gridScale;
                ctx.beginPath();
                ctx.arc(px, py, scaledPointSize, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = Math.max(1, gridScale * 0.5);
                ctx.stroke();
                
                drawnCount++;
                
                // Debug: log first few points
                if (idx < 3) {
                    const marker = point.isCreated ? 'CREATED' : 'CSV';
                    console.log(`Point ${idx}: ${marker}(${point.x.toFixed(2)}, ${point.y.toFixed(2)}) -> GridPx(${gridPixelXWithOffset.toFixed(0)}, ${gridPixelYFlippedWithOffset.toFixed(0)}) -> Screen(${px.toFixed(0)}, ${py.toFixed(0)})`);
                }
            });
            
            console.log('Drew', drawnCount, 'points,', visibleCount, 'visible on screen');
            
            // Draw a reference cross at the point cloud origin
            const originX = gridOffsetX + (pointOffsetX * gridScale);
            const originY = gridOffsetY + ((csvHeight * baseCellSize * pointScale + pointOffsetY) * gridScale);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(originX - 30, originY);
            ctx.lineTo(originX + 30, originY);
            ctx.moveTo(originX, originY - 30);
            ctx.lineTo(originX, originY + 30);
            ctx.stroke();
            
            ctx.restore();
        }

        // Draw cable group lines - lines from each point to the group center
        function drawCableGroups(ctx, gridOffsetX, gridOffsetY, gridScale, pointScale, pointOffsetX, pointOffsetY) {
            const baseCellSize = 60;
            const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;

            ctx.save();

            // Helper function to convert point coordinates to screen coordinates
            function pointToScreen(point) {
                // All points (including created ones) now use x,y coordinates
                const relativeX = point.x - pointCloudBounds.minX;
                const relativeY = point.y - pointCloudBounds.minY;

                const gridPixelX = relativeX * baseCellSize * pointScale;
                const gridPixelY = relativeY * baseCellSize * pointScale;

                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                const px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                const py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);

                return { x: px, y: py };
            }

            // Draw each cable group
            cableGroups.forEach((group, groupIndex) => {
                // Get center point screen coordinates
                const centerScreen = pointToScreen(group.center);

                // Draw lines from each point to center
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; // Black for cables
                ctx.lineWidth = Math.max(1, gridScale * 1.5);

                group.points.forEach(point => {
                    const pointScreen = pointToScreen(point);

                    ctx.beginPath();
                    ctx.moveTo(pointScreen.x, pointScreen.y);
                    ctx.lineTo(centerScreen.x, centerScreen.y);
                    ctx.stroke();
                });

                // Draw center point marker
                const centerMarkerSize = Math.max(8, gridScale * 10);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // Red for center
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = Math.max(2, gridScale * 2);

                ctx.beginPath();
                ctx.arc(centerScreen.x, centerScreen.y, centerMarkerSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw group number label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `bold ${Math.max(10, gridScale * 12)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`U${group.universeNum}-${group.groupInUniverse}`, centerScreen.x, centerScreen.y);
            });

            ctx.restore();

            console.log('Drew', cableGroups.length, 'cable groups');
        }

        // Helper function to find which universe a cell belongs to
        function getCellUniverse(cellCol, cellRow) {
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                    // Calculate X position by summing widths in the SAME ROW
                    let currentX = 0;
                    for (let c = 0; c < uCol; c++) {
                        currentX += getUniverseCols(uRow, c);
                    }

                    // Calculate Y position by summing heights in the SAME COLUMN
                    let currentY = 0;
                    for (let r = 0; r < uRow; r++) {
                        currentY += getUniverseRows(r, uCol);
                    }

                    const colsInUniverse = getUniverseCols(uRow, uCol);
                    const rowsInUniverse = getUniverseRows(uRow, uCol);

                    if (cellCol >= currentX && cellCol < currentX + colsInUniverse &&
                        cellRow >= currentY && cellRow < currentY + rowsInUniverse) {
                        return {
                            uRow: uRow,
                            uCol: uCol,
                            universeNum: (uRow * universeGrid.universesH) + uCol + 1,
                            cellInUniverseCol: cellCol - currentX,
                            cellInUniverseRow: cellRow - currentY
                        };
                    }
                }
            }
            return null; // Cell doesn't belong to any universe
        }

        // Draw dynamic grid directly to canvas (supports variable universe sizes with cut-out corners)
        // Draw row and column headers on all four edges (R1, R2... for rows, C1, C2... for columns)
        function drawRowColHeaders(ctx, offsetX, offsetY, scale, totalCols, totalRows) {
            const baseCellSize = 60;
            const headerSize = 30 * scale; // Size of header cells
            const gridWidth = totalCols * baseCellSize * scale;
            const gridHeight = totalRows * baseCellSize * scale;
            
            ctx.save();
            ctx.fillStyle = 'rgba(50, 50, 60, 0.9)';
            
            // Top column headers background
            ctx.fillRect(offsetX, offsetY - headerSize, gridWidth, headerSize);
            
            // Bottom column headers background
            ctx.fillRect(offsetX, offsetY + gridHeight, gridWidth, headerSize);
            
            // Left row headers background
            ctx.fillRect(offsetX - headerSize, offsetY, headerSize, gridHeight);
            
            // Right row headers background
            ctx.fillRect(offsetX + gridWidth, offsetY, headerSize, gridHeight);
            
            // Corner cells
            ctx.fillRect(offsetX - headerSize, offsetY - headerSize, headerSize, headerSize); // Top-left
            ctx.fillRect(offsetX + gridWidth, offsetY - headerSize, headerSize, headerSize); // Top-right
            ctx.fillRect(offsetX - headerSize, offsetY + gridHeight, headerSize, headerSize); // Bottom-left
            ctx.fillRect(offsetX + gridWidth, offsetY + gridHeight, headerSize, headerSize); // Bottom-right
            
            // Text style
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(8, 10 * scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Column headers (C1, C2, etc.) - top and bottom
            for (let col = 0; col < totalCols; col++) {
                const x = offsetX + (col + 0.5) * baseCellSize * scale;
                const colLabel = `C${col + 1}`;
                // Top
                ctx.fillText(colLabel, x, offsetY - headerSize / 2);
                // Bottom
                ctx.fillText(colLabel, x, offsetY + gridHeight + headerSize / 2);
            }
            
            // Row headers (R1, R2, etc.) - left and right
            for (let row = 0; row < totalRows; row++) {
                const y = offsetY + (row + 0.5) * baseCellSize * scale;
                const rowLabel = `R${row + 1}`;
                // Left
                ctx.fillText(rowLabel, offsetX - headerSize / 2, y);
                // Right
                ctx.fillText(rowLabel, offsetX + gridWidth + headerSize / 2, y);
            }
            
            // Draw header borders
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            
            // Top column header border
            ctx.strokeRect(offsetX, offsetY - headerSize, gridWidth, headerSize);
            // Bottom column header border
            ctx.strokeRect(offsetX, offsetY + gridHeight, gridWidth, headerSize);
            // Left row header border
            ctx.strokeRect(offsetX - headerSize, offsetY, headerSize, gridHeight);
            // Right row header border
            ctx.strokeRect(offsetX + gridWidth, offsetY, headerSize, gridHeight);
            
            // Corner borders
            ctx.strokeRect(offsetX - headerSize, offsetY - headerSize, headerSize, headerSize);
            ctx.strokeRect(offsetX + gridWidth, offsetY - headerSize, headerSize, headerSize);
            ctx.strokeRect(offsetX - headerSize, offsetY + gridHeight, headerSize, headerSize);
            ctx.strokeRect(offsetX + gridWidth, offsetY + gridHeight, headerSize, headerSize);
            
            ctx.restore();
        }
        
        // Draw crosshair with 50px gap around mouse cursor and labels at 100px
        function drawCrosshair(ctx, mouseX, mouseY, canvasWidth, canvasHeight, cellRow, cellCol) {
            if (mouseX < 0 || mouseY < 0) return;
            
            const gap = 50; // Gap around mouse cursor
            const labelDistance = 100; // Distance from mouse for labels
            
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // 50% transparent black
            ctx.lineWidth = 1;
            
            // Vertical line (top part)
            ctx.beginPath();
            ctx.moveTo(mouseX, 0);
            ctx.lineTo(mouseX, mouseY - gap);
            ctx.stroke();
            
            // Vertical line (bottom part)
            ctx.beginPath();
            ctx.moveTo(mouseX, mouseY + gap);
            ctx.lineTo(mouseX, canvasHeight);
            ctx.stroke();
            
            // Horizontal line (left part)
            ctx.beginPath();
            ctx.moveTo(0, mouseY);
            ctx.lineTo(mouseX - gap, mouseY);
            ctx.stroke();
            
            // Horizontal line (right part)
            ctx.beginPath();
            ctx.moveTo(mouseX + gap, mouseY);
            ctx.lineTo(canvasWidth, mouseY);
            ctx.stroke();
            
            // 45¬∞ diagonal line (top-right direction) - going from mouse up and to the right
            ctx.beginPath();
            const diag1StartX = mouseX + gap * Math.cos(Math.PI / 4);
            const diag1StartY = mouseY - gap * Math.sin(Math.PI / 4);
            ctx.moveTo(diag1StartX, diag1StartY);
            // Calculate where line exits canvas (top or right edge)
            const distToTop = mouseY;
            const distToRight = canvasWidth - mouseX;
            if (distToTop < distToRight) {
                // Hits top edge first
                ctx.lineTo(mouseX + distToTop, 0);
            } else {
                // Hits right edge first
                ctx.lineTo(canvasWidth, mouseY - distToRight);
            }
            ctx.stroke();
            
            // 45¬∞ diagonal line (bottom-left direction) - going from mouse down and to the left
            ctx.beginPath();
            const diag2StartX = mouseX - gap * Math.cos(Math.PI / 4);
            const diag2StartY = mouseY + gap * Math.sin(Math.PI / 4);
            ctx.moveTo(diag2StartX, diag2StartY);
            // Calculate where line exits canvas (bottom or left edge)
            const distToBottom = canvasHeight - mouseY;
            const distToLeft = mouseX;
            if (distToBottom < distToLeft) {
                // Hits bottom edge first
                ctx.lineTo(mouseX - distToBottom, canvasHeight);
            } else {
                // Hits left edge first
                ctx.lineTo(0, mouseY + distToLeft);
            }
            ctx.stroke();
            
            // Draw row and column labels if we have valid cell coordinates
            if (cellRow !== null && cellCol !== null && cellRow >= 0 && cellCol >= 0) {
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const rowLabel = `R${cellRow + 1}`;
                const colLabel = `C${cellCol + 1}`;
                
                // Draw label background and text helper
                const drawLabel = (text, x, y) => {
                    const padding = 4;
                    const metrics = ctx.measureText(text);
                    const textWidth = metrics.width;
                    const textHeight = 14;
                    
                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x - textWidth/2 - padding, y - textHeight/2 - padding, textWidth + padding*2, textHeight + padding*2);
                    
                    // Text
                    ctx.fillStyle = '#fff';
                    ctx.fillText(text, x, y);
                };
                
                // Column label on vertical line (above gap)
                if (mouseY - labelDistance > 0) {
                    drawLabel(colLabel, mouseX, mouseY - labelDistance);
                }
                
                // Row label on horizontal line (left of gap)
                if (mouseX - labelDistance > 0) {
                    drawLabel(rowLabel, mouseX - labelDistance, mouseY);
                }
            }
            
            ctx.restore();
        }

        function drawDynamicGrid(ctx, offsetX, offsetY, scale, colors) {
            const baseCellSize = 60;

            // Calculate total grid dimensions
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();

            // Draw cells globally (prevents overlaps, creates cut-out corners)
            for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                    // Find which universe this cell belongs to
                    const cellUniverse = getCellUniverse(cellCol, cellRow);

                    if (!cellUniverse) continue; // Skip cells that don't belong to any universe

                    const universeNum = cellUniverse.universeNum;
                    const hexColor = colors[universeNum] || 'CCCCCC';

                    // Calculate cell position
                    const x = cellCol * baseCellSize;
                    const y = cellRow * baseCellSize;
                    const cellWidth = baseCellSize;
                    const cellHeight = baseCellSize;

                    // Transform to screen coordinates
                    const screenX = offsetX + (x * scale);
                    const screenY = offsetY + (y * scale);
                    const screenWidth = cellWidth * scale;
                    const screenHeight = cellHeight * scale;

                    // Fill cell with universe color
                    ctx.fillStyle = '#' + hexColor;
                    ctx.fillRect(screenX, screenY, screenWidth, screenHeight);

                    // Draw cell border
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = Math.max(0.5, scale * 0.5);
                    ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);
                    
                    // Draw cell ID in top-left corner (for debugging)
                    if (scale > 0.2) {
                        ctx.fillStyle = 'rgba(0, 0, 128, 0.7)';
                        ctx.font = `${Math.max(5, scale * 6)}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`${cellRow},${cellCol}`, screenX + 2, screenY + 2);
                    }

                     // Draw cell text only if enabled
                     if (universeGrid.showCellText && scale > 0.3) {
                         const cellKey = `${cellRow},${cellCol}`;
                         const customData = cellCustomData.get(cellKey);
                         const boxNum = cellToBoxNumber.get(cellKey);
                         
                         if (customData) {
                             // Draw custom formatted cell content (without & prefix)
                             ctx.fillStyle = '#000';
                             ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                             ctx.textAlign = 'center';
                             
                             let yOffset = screenY + 5 * scale;
                             const lineHeight = Math.max(10, scale * 11);
                             
                             if (customData.index) {
                                 ctx.textBaseline = 'top';
                                 ctx.fillText(customData.index, screenX + screenWidth / 2, yOffset);
                                 yOffset += lineHeight;
                             }
                             if (customData.universe) {
                                 ctx.font = `bold ${Math.max(7, scale * 8)}px Arial`;
                                 ctx.fillText(`U${customData.universe}`, screenX + screenWidth / 2, yOffset);
                                 yOffset += lineHeight;
                             }
                             if (customData.box) {
                                 ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                                 ctx.fillText(`B${customData.box}`, screenX + screenWidth / 2, yOffset);
                                 yOffset += lineHeight;
                             } else if (boxNum !== undefined) {
                                 ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                                 ctx.fillText(`B${boxNum}`, screenX + screenWidth / 2, yOffset);
                                 yOffset += lineHeight;
                             } else {
                                 ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                                 ctx.textBaseline = 'bottom';
                                 ctx.fillText('B', screenX + screenWidth / 2, screenY + screenHeight - 5 * scale);
                             }
                             if (customData.note) {
                                 ctx.font = `${Math.max(6, scale * 7)}px Arial`;
                                 ctx.fillText(`?${customData.note}`, screenX + screenWidth / 2, yOffset);
                             }
                         } else {
                             // Default format
                             ctx.fillStyle = '#000';
                             ctx.font = `${Math.max(8, scale * 9)}px Arial`;
                             ctx.textAlign = 'center';
                             ctx.textBaseline = 'top';
                             ctx.fillText(`${cellUniverse.cellInUniverseCol + 1}`, screenX + screenWidth / 2, screenY + 5 * scale);

                             ctx.font = `bold ${Math.max(8, scale * 9)}px Arial`;
                             ctx.textBaseline = 'middle';
                             ctx.fillText(`U${universeNum}`, screenX + screenWidth / 2, screenY + screenHeight / 2);

                             ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                             ctx.textBaseline = 'bottom';
                             const bLabel = boxNum !== undefined ? `B${boxNum}` : 'B';
                             ctx.fillText(bLabel, screenX + screenWidth / 2, screenY + screenHeight - 5 * scale);
                         }
                     }
                }
            }

            // Draw universe boundaries
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(2, scale * 3);

            // Draw boundaries between different universes
            for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                    const cellUniverse = getCellUniverse(cellCol, cellRow);
                    if (!cellUniverse) continue;

                    const x = cellCol * baseCellSize;
                    const y = cellRow * baseCellSize;

                    // Check right edge
                    const rightNeighbor = getCellUniverse(cellCol + 1, cellRow);
                    if (!rightNeighbor || rightNeighbor.universeNum !== cellUniverse.universeNum) {
                        const rightX = offsetX + ((x + baseCellSize) * scale);
                        const topY = offsetY + (y * scale);
                        const bottomY = offsetY + ((y + baseCellSize) * scale);
                        ctx.beginPath();
                        ctx.moveTo(rightX, topY);
                        ctx.lineTo(rightX, bottomY);
                        ctx.stroke();
                    }

                    // Check bottom edge
                    const bottomNeighbor = getCellUniverse(cellCol, cellRow + 1);
                    if (!bottomNeighbor || bottomNeighbor.universeNum !== cellUniverse.universeNum) {
                        const leftX = offsetX + (x * scale);
                        const rightX = offsetX + ((x + baseCellSize) * scale);
                        const bottomY = offsetY + ((y + baseCellSize) * scale);
                        ctx.beginPath();
                        ctx.moveTo(leftX, bottomY);
                        ctx.lineTo(rightX, bottomY);
                        ctx.stroke();
                    }
                }
            }

            // Draw large universe labels if text is enabled
            if (universeGrid.showCellText && scale > 0.5) {
                for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                    for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                        // Calculate X position by summing widths in the SAME ROW
                        let currentX = 0;
                        for (let c = 0; c < uCol; c++) {
                            currentX += getUniverseCols(uRow, c);
                        }

                        // Calculate Y position by summing heights in the SAME COLUMN
                        let currentY = 0;
                        for (let r = 0; r < uRow; r++) {
                            currentY += getUniverseRows(r, uCol);
                        }

                        const colsInUniverse = getUniverseCols(uRow, uCol);
                        const rowsInUniverse = getUniverseRows(uRow, uCol);
                        const universeNum = (uRow * universeGrid.universesH) + uCol + 1;

                        const centerX = offsetX + ((currentX + colsInUniverse / 2) * baseCellSize * scale);
                        const centerY = offsetY + ((currentY + rowsInUniverse / 2) * baseCellSize * scale);

                        const fontSize = Math.min(baseCellSize * 3 * scale, 120);
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 4;
                        ctx.strokeText(`U${universeNum}`, centerX, centerY);

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillText(`U${universeNum}`, centerX, centerY);
                    }
                }
            }
        }
        
        // Draw the grid with zoom and pan (dynamic rendering)
        function drawGridPreview(universesH, universesV, colors, colsPerUniverse, rowsPerUniverse) {
            const canvas = document.getElementById('gridCanvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get canvas context!');
                return;
            }

            // Set canvas to full window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Clear canvas with background color
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate total dimensions in cells
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            // Calculate scale to fit all content in viewport
            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;

            // Calculate display dimensions
            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;

            // Center offset plus pan
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;

            // Draw the dynamic grid with alpha
            const mapAlpha = parseFloat(document.getElementById('mapAlpha')?.value || 100) / 100;
            if (mapAlpha > 0) {
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.globalAlpha = mapAlpha;
                drawDynamicGrid(ctx, offsetX, offsetY, scale, colors);
                ctx.globalAlpha = 1.0; // Reset alpha for other elements
            }
            
            // Draw cable groups if enabled
            const showCables = document.getElementById('showCableGroups')?.checked;
            if (showCables && pointCloudLoaded && cableGroups.length > 0) {
                const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
                const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
                console.log('Drawing cable groups:', cableGroups.length);
                drawCableGroups(ctx, offsetX, offsetY, scale, pointScale, pointOffsetX, pointOffsetY);
            }

            // Draw point cloud overlay if enabled
            const showPoints = document.getElementById('showPointCloud')?.checked;
            if (showPoints && pointCloudLoaded && pointCloudData.length > 0) {
                const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                const pointSize = parseFloat(document.getElementById('pointSize')?.value || 20);
                const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
                const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
                console.log('Drawing points:', pointCloudData.length, 'scale:', pointScale, 'size:', pointSize);
                drawPointCloud(ctx, offsetX, offsetY, scale, pointScale, pointSize, pointOffsetX, pointOffsetY);
            }
            
            // Draw row and column headers if enabled
            const showHeaders = document.getElementById('showRowColHeaders')?.checked;
            if (showHeaders) {
                drawRowColHeaders(ctx, offsetX, offsetY, scale, totalCols, totalRows);
            }
            
            // Draw crosshair if enabled
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair && currentMouseX >= 0 && currentMouseY >= 0) {
                // Calculate which cell the mouse is over
                const gridX = (currentMouseX - offsetX) / scale;
                const gridY = (currentMouseY - offsetY) / scale;
                const cellCol = Math.floor(gridX / baseCellSize);
                const cellRow = Math.floor(gridY / baseCellSize);
                
                // Only pass valid cell coordinates (within grid bounds)
                const validCellCol = (cellCol >= 0 && cellCol < totalCols) ? cellCol : null;
                const validCellRow = (cellRow >= 0 && cellRow < totalRows) ? cellRow : null;
                
                drawCrosshair(ctx, currentMouseX, currentMouseY, canvas.width, canvas.height, validCellRow, validCellCol);
            }
            
            // Update zoom label
            const zoomLabel = document.getElementById('zoomLevel');
            if (zoomLabel) {
                zoomLabel.textContent = Math.round(zoom * 100) + '%';
            }
        }
        
        // Update preview
        function updatePreview() {
            try {
                console.log('updatePreview called');

                const cols = parseInt(document.getElementById('cols').value) || 20;
                const rows = parseInt(document.getElementById('rows').value) || 10;
                const universesH = parseInt(document.getElementById('universes_h').value) || 6;
                const universesV = parseInt(document.getElementById('universes_v').value) || 5;

                console.log('Grid config:', { cols, rows, universesH, universesV });

                // Initialize universe grid if not already initialized or if dimensions changed
                if (universeGrid.universes.length === 0 ||
                    universeGrid.universesH !== universesH ||
                    universeGrid.universesV !== universesV) {
                    initializeUniverseGrid(cols, rows, universesH, universesV);
                }

                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const totalUniverses = universesH * universesV;

                // Calculate average cells per universe
                let totalCellsInAllUniverses = 0;
                for (let uRow = 0; uRow < universesV; uRow++) {
                    for (let uCol = 0; uCol < universesH; uCol++) {
                        const cols = getUniverseCols(uRow, uCol);
                        const rows = getUniverseRows(uRow, uCol);
                        totalCellsInAllUniverses += cols * rows;
                    }
                }
                const cellsPerUniverse = Math.round(totalCellsInAllUniverses / totalUniverses);
                const totalCells = totalCols * totalRows;
                
                // Update stats
                const elem1 = document.getElementById('totalUniverses');
                const elem2 = document.getElementById('gridSize');
                const elem3 = document.getElementById('cellsPerUniverse');
                const elem4 = document.getElementById('totalCells');
                
                if (elem1) {
                    elem1.textContent = totalUniverses;
                    console.log('Updated totalUniverses:', totalUniverses);
                } else {
                    console.error('totalUniverses element not found');
                }
                
                if (elem2) {
                    elem2.textContent = `${totalRows + 1} √ó ${totalCols + 1}`;
                    console.log('Updated gridSize');
                } else {
                    console.error('gridSize element not found');
                }
                
                if (elem3) {
                    elem3.textContent = cellsPerUniverse.toLocaleString();
                    console.log('Updated cellsPerUniverse:', cellsPerUniverse);
                } else {
                    console.error('cellsPerUniverse element not found');
                }
                
                if (elem4) {
                    elem4.textContent = totalCells.toLocaleString();
                    console.log('Updated totalCells:', totalCells);
                } else {
                    console.error('totalCells element not found');
                }
                
                // Calculate cable groups if we have points (needed for box numbers in cells)
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    calculateCableGroups();
                }
                
                // Draw visual preview with cells
                const colors = generateUniverseColors(totalUniverses);
                console.log('Generated colors for', totalUniverses, 'universes');
                drawGridPreview(universesH, universesV, colors, cols, rows);
                console.log('Draw complete');
                
            } catch (error) {
                console.error('Preview update error:', error);
            }
        }
        
        // Generate cell label with custom data support
        function generateCellLabel(rowInUniverse, colInUniverse, universeNum, boxNum = null, cellRow = null, cellCol = null) {
            // Check for custom cell data
            let customData = null;
            if (cellRow !== null && cellCol !== null) {
                const cellKey = `${cellRow},${cellCol}`;
                customData = cellCustomData.get(cellKey);
            }
            
            if (customData) {
                // Use custom data without & prefix in cell content
                const lines = [];
                if (customData.index) {
                    lines.push(customData.index);
                }
                if (customData.universe) {
                    lines.push(`U${customData.universe}`);
                }
                if (customData.box) {
                    lines.push(`B${customData.box}`);
                } else if (boxNum !== null) {
                    // Fallback to calculated box number
                    lines.push(`B${boxNum}`);
                } else {
                    lines.push('B');
                }
                if (customData.note) {
                    lines.push(`?${customData.note}`);
                }
                return lines.join('\n') + '\n';
            } else {
                // Default format
                const colLabel = `${colInUniverse + 1}`;  // 1-20 across the row
                const universeLabel = `U${universeNum}`;
                const bLabel = boxNum !== null ? `B${boxNum}` : 'B';
                return `${colLabel}\n${universeLabel}-${bLabel}\n`;
            }
        }
        
        // Generate map data using actual universe grid structure (respects custom boundaries)
        function generateMapData() {
            // Calculate total dimensions from actual universe grid
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            
            const grid = [];
            
            // Header row
            const headerRow = [''];
            for (let col = 0; col < totalCols; col++) {
                headerRow.push(`C${col + 1}`);
            }
            grid.push(headerRow);
            
            // Data rows - using dynamic universe grid
            for (let row = 0; row < totalRows; row++) {
                const rowData = [`R${row + 1}`];
                
                // For each column, determine which universe and position within that universe
                for (let col = 0; col < totalCols; col++) {
                    // Find which universe this cell belongs to
                    let cellValue = '';
                    let foundUniverse = false;
                    
                    for (let uRow = 0; uRow < universeGrid.universesV && !foundUniverse; uRow++) {
                        for (let uCol = 0; uCol < universeGrid.universesH && !foundUniverse; uCol++) {
                            // Calculate X position by summing widths in the SAME ROW
                            let currentX = 0;
                            for (let c = 0; c < uCol; c++) {
                                currentX += getUniverseCols(uRow, c);
                            }
                            
                            // Calculate Y position by summing heights in the SAME COLUMN
                            let currentY = 0;
                            for (let r = 0; r < uRow; r++) {
                                currentY += getUniverseRows(r, uCol);
                            }
                            
                            const colsInUniverse = getUniverseCols(uRow, uCol);
                            const rowsInUniverse = getUniverseRows(uRow, uCol);
                            
                            // Check if this cell is in this universe
                            if (col >= currentX && col < currentX + colsInUniverse &&
                                row >= currentY && row < currentY + rowsInUniverse) {
                                
                                const colInUniverse = col - currentX;
                                const rowInUniverse = row - currentY + 1; // +1 because B1, B2, etc.
                                const universeNum = (uRow * universeGrid.universesH) + uCol + 1;
                                
                                // Get box number for this cell
                                const cellKey = `${row},${col}`;
                                const boxNum = cellToBoxNumber.get(cellKey);
                                
                                cellValue = generateCellLabel(rowInUniverse, colInUniverse, universeNum, boxNum, row, col);
                                foundUniverse = true;
                            }
                        }
                    }
                    
                    rowData.push(cellValue);
                }
                
                grid.push(rowData);
            }
            
            return grid;
        }
        
        // RGB to hex
        function rgbToHex(r, g, b) {
            return [r, g, b].map(x => {
                const hex = Math.round(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }
        
        // Hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Apply transparency to color
        function applyTransparency(hexColor, opacity = 0.8) {
            const rgb = hexToRgb(hexColor);
            if (!rgb) return hexColor;
            
            // Blend with white background
            const r = Math.round(rgb.r * opacity + 255 * (1 - opacity));
            const g = Math.round(rgb.g * opacity + 255 * (1 - opacity));
            const b = Math.round(rgb.b * opacity + 255 * (1 - opacity));
            
            return rgbToHex(r, g, b);
        }
        
        // Generate Excel file
        function generateExcel(event) {
            event.preventDefault();
            
            const loading = document.getElementById('loading');
            const submitBtn = document.querySelector('button[type="submit"]');
            const errorBox = document.getElementById('errorBox');
            
            loading.classList.add('show');
            submitBtn.disabled = true;
            errorBox.classList.remove('show');
            
            try {
                const cols = parseInt(document.getElementById('cols').value);
                const rows = parseInt(document.getElementById('rows').value);
                const universesH = parseInt(document.getElementById('universes_h').value);
                const universesV = parseInt(document.getElementById('universes_v').value);
                
                // Ensure cable groups are calculated (uses same logic as visual display)
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    calculateCableGroups();
                }
                
                // Map points to cells using EXACT same logic as visual rendering
                const cellsWithPoints = new Map(); // key: "row,col", value: { left: bool, boxNum: number }
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                    const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
                    const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
                    const baseCellSize = 60; // Same as rendering
                    const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
                    const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;
                    
                    pointCloudData.forEach((point, idx) => {
                        // All points (including created ones) now use x,y coordinates
                        const relativeX = point.x - pointCloudBounds.minX;
                        const relativeY = point.y - pointCloudBounds.minY;
                        
                        // Convert to grid pixel space
                        const gridPixelX = relativeX * baseCellSize * pointScale;
                        const gridPixelY = relativeY * baseCellSize * pointScale;
                        
                        // Flip Y coordinate
                        const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                        
                        // Apply offsets (in grid space)
                        const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                        const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;
                        
                        // Convert to cell indices (each cell is baseCellSize pixels)
                        const cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                        const cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);
                        
                        // Add 1 to account for header row/col in Excel
                        const excelRow = cellRow + 1;
                        const excelCol = cellCol + 1;
                        
                        // Get box number from the cellToBoxNumber map (populated by calculateCableGroups)
                        const cellKey = `${cellRow},${cellCol}`;
                        const boxNum = cellToBoxNumber.get(cellKey);
                        
                        if (boxNum !== undefined) {
                            // Determine if this is an even or odd CSV row (for staggered positioning)
                            // For created points, default to left (even row)
                            let isOffsetLeft = true;
                            if (!point.isCreated && pointCloudPitch && pointCloudPitch.y > 0) {
                                const csvRowIndex = Math.floor((point.y - pointCloudBounds.minY) / pointCloudPitch.y);
                                isOffsetLeft = csvRowIndex % 2 === 0;
                            }
                            
                            const key = `${excelRow},${excelCol}`;
                            cellsWithPoints.set(key, { left: isOffsetLeft, boxNum: boxNum });
                        }
                    });
                    
                    console.log('Mapped', cellsWithPoints.size, 'points to cells using cable groups');
                }
                
                // Generate the grid data
                const grid = generateMapData();
                
                // Generate colors for universes
                const totalUniverses = universesH * universesV;
                const colors = generateUniverseColors(totalUniverses);
                
                // Create workbook with cell styles option
                const wb = XLSX.utils.book_new();
                wb.Props = {
                    Title: "Spread-Map",
                    Author: "Spread-Map Generator"
                };
                
                // Create worksheet manually to have better control
                const ws = {};
                const range = {
                    s: { c: 0, r: 0 },
                    e: { c: grid[0].length - 1, r: grid.length - 1 }
                };
                
                // Fill worksheet with data and styling
                for (let R = 0; R < grid.length; R++) {
                    for (let C = 0; C < grid[R].length; C++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                        let cellValue = grid[R][C];
                        
                        // Check if this cell has a point
                        const pointKey = `${R},${C}`;
                        const cellKey = `${R - 1},${C - 1}`; // Convert to 0-based for cellCustomData
                        const customData = cellCustomData.get(cellKey);
                        
                        if (cellsWithPoints.has(pointKey) && R > 0 && C > 0) {
                            const pointInfo = cellsWithPoints.get(pointKey);
                            
                            if (customData) {
                                // Custom format - add dot to first line and update box if needed
                                const lines = cellValue.split('\n');
                                if (lines.length > 0) {
                                    // Add dot to first line
                                    if (pointInfo.left) {
                                        lines[0] = '‚óè ' + lines[0];
                                    } else {
                                        lines[0] = lines[0] + ' ‚óè';
                                    }
                                    
                                    // Update box number if point has one
                                    if (pointInfo.boxNum) {
                                        // Find and update the B line (without & prefix)
                                        for (let i = 0; i < lines.length; i++) {
                                            const trimmed = lines[i].trim();
                                            if (trimmed.startsWith('B') && trimmed.length > 1 && !isNaN(trimmed.substring(1))) {
                                                lines[i] = `B${pointInfo.boxNum}`;
                                                break;
                                            } else if (trimmed === 'B') {
                                                lines[i] = `B${pointInfo.boxNum}`;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    cellValue = lines.join('\n');
                                }
                            } else {
                                // Default format
                                const lines = cellValue.split('\n');
                                if (lines.length >= 2) {
                                    // Add dot on first line
                                    if (pointInfo.left) {
                                        lines[0] = '‚óè ' + lines[0];
                                    } else {
                                        lines[0] = lines[0] + ' ‚óè';
                                    }
                                    
                                    // Update the B number
                                    if (pointInfo.boxNum) {
                                        lines[1] = lines[1].replace(/B\d+/, `B${pointInfo.boxNum}`);
                                    }
                                    
                                    cellValue = lines.join('\n');
                                }
                            }
                        }
                        
                        const cell = {
                            v: cellValue,
                            t: 's', // string type
                            s: {}
                        };
                        
                        // Common styles
                        cell.s = {
                            alignment: {
                                horizontal: 'center',
                                vertical: 'top',
                                wrapText: true
                            },
                            border: {
                                top: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                bottom: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                left: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                right: { style: 'thin', color: { rgb: 'D3D3D3' } }
                            },
                            font: { sz: 9, name: 'Arial' }
                        };
                        
                        // Header styling
                        if (R === 0 || C === 0) {
                            cell.s.fill = {
                                patternType: 'solid',
                                fgColor: { rgb: 'D3D3D3' }
                            };
                            cell.s.font.bold = true;
                            cell.s.alignment.vertical = 'center';
                        } else {
                            // Data cell - extract universe number and apply color
                            if (typeof cellValue === 'string' && cellValue.includes('U')) {
                                const match = cellValue.match(/U(\d+)/);
                                if (match) {
                                    const universeNum = parseInt(match[1]);
                                    if (colors[universeNum]) {
                                        // Check if this cell has a point - if not, make it very transparent
                                        const pointKey = `${R},${C}`;
                                        const hasPoint = cellsWithPoints.has(pointKey);
                                        const opacity = hasPoint ? 0.8 : 0.15; // Full opacity for points, very transparent for empty cells
                                        
                                        const transparentColor = applyTransparency(colors[universeNum], opacity);
                                        cell.s.fill = {
                                            patternType: 'solid',
                                            fgColor: { rgb: transparentColor }
                                        };
                                    }
                                }
                            }
                        }
                        
                        ws[cellAddress] = cell;
                    }
                }
                
                ws['!ref'] = XLSX.utils.encode_range(range);
                
                // Set column widths and row heights for square cells
                // Excel uses different units: row height in points, column width in character units
                // To create square cells: 50pt height ‚âà 7.5 character width
                const colWidths = [];
                for (let i = 0; i < grid[0].length; i++) {
                    colWidths.push({ wch: 7.5 });
                }
                ws['!cols'] = colWidths;
                
                const rowHeights = [];
                for (let i = 0; i < grid.length; i++) {
                    rowHeights.push({ hpt: 50 });
                }
                ws['!rows'] = rowHeights;
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Spread-Map');
                
                // Generate file and download with cellStyles option
                XLSX.writeFile(wb, 'spread-map.xlsx', { cellStyles: true, bookType: 'xlsx' });
                
                loading.classList.remove('show');
                submitBtn.disabled = false;
                
            } catch (error) {
                console.error('Generation error:', error);
                errorBox.textContent = '‚ö†Ô∏è Error: ' + error.message;
                errorBox.classList.add('show');
                loading.classList.remove('show');
                submitBtn.disabled = false;
            }
        }
        
        // Event listeners
        document.getElementById('mapForm').addEventListener('submit', generateExcel);
        
        // Auto-update for all inputs except grid layout fields and CSV upload
        document.querySelectorAll('input:not(#csvFileInput):not(#cols):not(#rows):not(#universes_h):not(#universes_v)').forEach(input => {
            input.addEventListener('input', () => {
                updatePreview();
                saveSettings();
            });
            input.addEventListener('change', () => {
                updatePreview();
                saveSettings();
            });
        });
        
        // Grid layout fields - only save on change, don't auto-update preview
        ['cols', 'rows', 'universes_h', 'universes_v'].forEach(id => {
            document.getElementById(id).addEventListener('change', saveSettings);
        });
        
        // Apply button for grid layout changes
        document.getElementById('applyGridBtn').addEventListener('click', () => {
            // Enable cell text generation
            universeGrid.showCellText = true;

            // Get current dimensions from input fields
            const cols = parseInt(document.getElementById('cols').value) || 20;
            const rows = parseInt(document.getElementById('rows').value) || 10;
            const universesH = parseInt(document.getElementById('universes_h').value) || 6;
            const universesV = parseInt(document.getElementById('universes_v').value) || 5;

            // Check if grid dimensions have changed (requires reset)
            const dimensionsChanged =
                universeGrid.universes.length === 0 ||
                universeGrid.universesH !== universesH ||
                universeGrid.universesV !== universesV ||
                (universeGrid.universes.length > 0 &&
                 universeGrid.universes[0].length > 0 &&
                 (universeGrid.universes[0][0].cols !== cols ||
                  universeGrid.universes[0][0].rows !== rows));

            if (dimensionsChanged) {
                // Reset universe boundaries to uniform dimensions
                console.log('Grid dimensions changed - resetting universe boundaries');
                initializeUniverseGrid(cols, rows, universesH, universesV);
            } else {
                console.log('Grid dimensions unchanged - keeping custom boundaries');
            }

            // Always recalculate cable groups based on current grid layout
            if (pointCloudLoaded && pointCloudData.length > 0) {
                calculateCableGroups();
                console.log('Cable groups recalculated');
            }

            updatePreview();
            saveSettings();
        });
        
        // Spreadsheet file upload handler (CSV or Excel)
        document.getElementById('csvFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const fileName = file.name.toLowerCase();
                const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        if (isExcel) {
                            // Parse Excel file
                            const data = parseExcelFile(event.target.result);
                            const format = detectFileFormat(data, true);
                            
                            console.log('Detected format:', format);
                            
                            if (format === 'exported-map') {
                                // Import exported map
                                const mapData = parseExportedMap(data.worksheet);
                                importExportedMap(mapData);
                                console.log('Exported map loaded successfully');
                            } else if (format === 'point-cloud') {
                                // Convert Excel to CSV-like data and parse
                                const worksheet = data.worksheet;
                                const csvData = XLSX.utils.sheet_to_csv(worksheet);
                                parseCSV(csvData);
                                updatePreview();
                                console.log('Point cloud Excel loaded successfully');
                            } else {
                                throw new Error('Unknown Excel file format');
                            }
                        } else {
                            // Parse CSV file
                            const csvText = event.target.result;
                            const format = detectFileFormat(csvText, false);
                            
                            if (format === 'point-cloud') {
                                parseCSV(csvText);
                                updatePreview();
                                console.log('Point cloud CSV loaded successfully');
                            } else {
                                throw new Error('CSV format not supported for exported maps. Please use Excel files.');
                            }
                        }
                    } catch (error) {
                        console.error('Failed to parse file:', error);
                        alert('Failed to load file: ' + error.message);
                    }
                };
                
                if (isExcel) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            }
        });
        
        // Point cloud scale slider value display
        document.getElementById('pointScale').addEventListener('input', function() {
            document.getElementById('pointScaleValue').textContent = parseFloat(this.value).toFixed(2) + 'x';
        });
        
        // Point size slider value display
        document.getElementById('pointSize').addEventListener('input', function() {
            document.getElementById('pointSizeValue').textContent = this.value + 'px';
        });
        
        // Point offset sliders value display
        document.getElementById('pointOffsetX').addEventListener('input', function() {
            document.getElementById('pointOffsetXValue').textContent = this.value;
        });
        
        document.getElementById('pointOffsetY').addEventListener('input', function() {
            document.getElementById('pointOffsetYValue').textContent = this.value;
        });
        
        // Map alpha slider value display
        document.getElementById('mapAlpha').addEventListener('input', function() {
            document.getElementById('mapAlphaValue').textContent = this.value + '%';
        });
        
        // Row/column headers checkbox
        document.getElementById('showRowColHeaders').addEventListener('change', function() {
            saveSettings();
            updatePreview();
        });
        
        // Crosshair checkbox
        document.getElementById('showCrosshair').addEventListener('change', function() {
            saveSettings();
            updatePreview();
        });
        
        // Reset point scale button
        document.getElementById('resetPointScale').addEventListener('click', function() {
            if (pointCloudPitch.y > 0) {
                const idealScale = 1 / pointCloudPitch.y;
                document.getElementById('pointScale').value = idealScale.toFixed(3);
                document.getElementById('pointScaleValue').textContent = idealScale.toFixed(2) + 'x';
                saveSettings();
                updatePreview();
                console.log('Reset point scale to ideal:', idealScale.toFixed(3));
            } else {
                alert('No point cloud loaded yet. Please load a CSV file first.');
            }
        });

        // Initialize the application
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                cols: document.getElementById('cols').value,
                rows: document.getElementById('rows').value,
                universesH: document.getElementById('universes_h').value,
                universesV: document.getElementById('universes_v').value,
                mapAlpha: document.getElementById('mapAlpha').value,
                showCableGroups: document.getElementById('showCableGroups').checked,
                showPointCloud: document.getElementById('showPointCloud').checked,
                showRowColHeaders: document.getElementById('showRowColHeaders').checked,
                showCrosshair: document.getElementById('showCrosshair').checked,
                pointScale: document.getElementById('pointScale').value,
                pointSize: document.getElementById('pointSize').value,
                pointOffsetX: document.getElementById('pointOffsetX').value,
                pointOffsetY: document.getElementById('pointOffsetY').value
            };
            localStorage.setItem('spreadMapSettings', JSON.stringify(settings));
            console.log('Settings saved:', settings);
        }
        
        // Load settings from localStorage
        function loadSettings() {
            try {
                const saved = localStorage.getItem('spreadMapSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    console.log('Settings loaded:', settings);
                    
                    // Restore values
                    if (settings.cols) document.getElementById('cols').value = settings.cols;
                    if (settings.rows) document.getElementById('rows').value = settings.rows;
                    if (settings.universesH) document.getElementById('universes_h').value = settings.universesH;
                    if (settings.universesV) document.getElementById('universes_v').value = settings.universesV;
                    if (settings.mapAlpha !== undefined) document.getElementById('mapAlpha').value = settings.mapAlpha;
                    if (settings.showCableGroups !== undefined) document.getElementById('showCableGroups').checked = settings.showCableGroups;
                    if (settings.showPointCloud !== undefined) document.getElementById('showPointCloud').checked = settings.showPointCloud;
                    if (settings.showRowColHeaders !== undefined) document.getElementById('showRowColHeaders').checked = settings.showRowColHeaders;
                    if (settings.showCrosshair !== undefined) document.getElementById('showCrosshair').checked = settings.showCrosshair;
                    if (settings.pointScale) document.getElementById('pointScale').value = settings.pointScale;
                    if (settings.pointSize) document.getElementById('pointSize').value = settings.pointSize;
                    if (settings.pointOffsetX) document.getElementById('pointOffsetX').value = settings.pointOffsetX;
                    if (settings.pointOffsetY) document.getElementById('pointOffsetY').value = settings.pointOffsetY;
                    
                    // Update slider displays
                    document.getElementById('mapAlphaValue').textContent = (settings.mapAlpha || 100) + '%';
                    document.getElementById('pointScaleValue').textContent = parseFloat(settings.pointScale || 1).toFixed(2) + 'x';
                    document.getElementById('pointSizeValue').textContent = (settings.pointSize || 20) + 'px';
                    document.getElementById('pointOffsetXValue').textContent = settings.pointOffsetX || 0;
                    document.getElementById('pointOffsetYValue').textContent = settings.pointOffsetY || 0;
                }
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }
        
        function initApp() {
            console.log('=== Initializing App ===');
            console.log('Canvas exists:', !!document.getElementById('gridCanvas'));
            console.log('Stats elements exist:', {
                totalUniverses: !!document.getElementById('totalUniverses'),
                gridSize: !!document.getElementById('gridSize'),
                cellsPerUniverse: !!document.getElementById('cellsPerUniverse'),
                totalCells: !!document.getElementById('totalCells')
            });
            
            // Load saved settings
            loadSettings();
            
            // Load point cloud data
            loadPointCloud();
            
            // Initial preview
            updatePreview();
            
            console.log('=== App Initialized ===');
        }
        
        // Wait for DOM to be fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
        
        // Fallback - also try after a delay
        setTimeout(initApp, 100);
        
        // Redraw on window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updatePreview, 200);
        });
        
        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', function() {
            zoom = Math.max(0.8, Math.min(zoom * 1.2, 20));
            updatePreview();
        });
        
        document.getElementById('zoomOut').addEventListener('click', function() {
            zoom = Math.max(zoom / 1.2, 0.8);
            updatePreview();
        });
        
        // Mouse wheel zoom (zoom to cursor position)
        document.getElementById('gridCanvas').addEventListener('wheel', function(e) {
            e.preventDefault();

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;

            // Calculate current zoom parameters
            const oldZoom = zoom;
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            const newZoom = Math.max(0.8, Math.min(20, zoom * (1 + delta)));

            // Calculate the mouse position in world space before zoom
            // Use actual grid dimensions instead of cachedGridImage
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);

            const oldScale = baseScale * oldZoom;
            const newScale = baseScale * newZoom;

            const oldGridWidth = gridPixelWidth * oldScale;
            const oldGridHeight = gridPixelHeight * oldScale;
            const newGridWidth = gridPixelWidth * newScale;
            const newGridHeight = gridPixelHeight * newScale;

            const oldBaseOffsetX = (canvas.width - oldGridWidth) / 2;
            const oldBaseOffsetY = (canvas.height - oldGridHeight) / 2;
            const newBaseOffsetX = (canvas.width - newGridWidth) / 2;
            const newBaseOffsetY = (canvas.height - newGridHeight) / 2;

            // Mouse position relative to grid origin before zoom
            const oldOffsetX = oldBaseOffsetX + panX;
            const oldOffsetY = oldBaseOffsetY + panY;
            const worldX = (mouseX - oldOffsetX) / oldScale;
            const worldY = (mouseY - oldOffsetY) / oldScale;

            // Adjust pan so the same world point ends up under the mouse after zoom
            panX = mouseX - newBaseOffsetX - worldX * newScale;
            panY = mouseY - newBaseOffsetY - worldY * newScale;

            zoom = newZoom;
            updatePreview();
        }, { passive: false });
        
        // Detect if mouse is near a boundary line segment
        function detectBoundaryAtPosition(mouseX, mouseY) {
            const canvas = document.getElementById('gridCanvas');
            const baseCellSize = 60;
            const threshold = 10; // pixels

            // Calculate grid transformation
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;

            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;

            // Check vertical boundaries (between specific universe pairs)
            let currentY = 0;
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                let currentX = 0;
                const rowsInUniverse = getUniverseRows(uRow, 0);

                for (let uCol = 0; uCol < universeGrid.universesH - 1; uCol++) {
                    const colsInUniverse = getUniverseCols(uRow, uCol);
                    currentX += colsInUniverse;

                    const boundaryX = offsetX + (currentX * baseCellSize * scale);
                    const topY = offsetY + (currentY * baseCellSize * scale);
                    const bottomY = offsetY + ((currentY + rowsInUniverse) * baseCellSize * scale);

                    // Check if mouse is near this vertical boundary segment
                    if (Math.abs(mouseX - boundaryX) < threshold &&
                        mouseY >= topY && mouseY <= bottomY) {
                        return {
                            type: 'vertical',
                            leftURow: uRow,
                            leftUCol: uCol,
                            rightURow: uRow,
                            rightUCol: uCol + 1
                        };
                    }
                }

                currentY += rowsInUniverse;
            }

            // Check horizontal boundaries (between specific universe pairs)
            let currentX = 0;
            for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                let currentY = 0;
                const colsInFirstRow = getUniverseCols(0, uCol);

                for (let uRow = 0; uRow < universeGrid.universesV - 1; uRow++) {
                    const rowsInUniverse = getUniverseRows(uRow, uCol);
                    const colsInThisUniverse = getUniverseCols(uRow, uCol);
                    currentY += rowsInUniverse;

                    const boundaryY = offsetY + (currentY * baseCellSize * scale);
                    const leftX = offsetX + (currentX * baseCellSize * scale);
                    const rightX = offsetX + ((currentX + colsInThisUniverse) * baseCellSize * scale);

                    // Check if mouse is near this horizontal boundary segment
                    if (Math.abs(mouseY - boundaryY) < threshold &&
                        mouseX >= leftX && mouseX <= rightX) {
                        return {
                            type: 'horizontal',
                            topURow: uRow,
                            topUCol: uCol,
                            bottomURow: uRow + 1,
                            bottomUCol: uCol
                        };
                    }
                }

                currentX += colsInFirstRow;
            }

            return null;
        }

        // Mouse drag to pan OR drag boundaries
        const canvas = document.getElementById('gridCanvas');
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;

            const boundary = detectBoundaryAtPosition(mouseX, mouseY);

            if (boundary) {
                draggingBoundary = boundary;
                dragStartX = mouseX;
                dragStartY = mouseY;
                canvas.style.cursor = boundary.type === 'vertical' ? 'ew-resize' : 'ns-resize';
            } else {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;
            
            // Update global mouse position for crosshair
            currentMouseX = mouseX;
            currentMouseY = mouseY;
            
            // Redraw if crosshair is enabled (for smooth crosshair tracking)
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair && !isDragging && !draggingBoundary) {
                updatePreview();
            }

            if (draggingBoundary) {
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;
                const availableWidth = canvas.width * 0.9;
                const availableHeight = canvas.height * 0.9;
                const scaleX = availableWidth / gridPixelWidth;
                const scaleY = availableHeight / gridPixelHeight;
                const baseScale = Math.min(scaleX, scaleY);
                const scale = baseScale * zoom;

                if (draggingBoundary.type === 'vertical') {
                    const deltaX = mouseX - dragStartX;
                    const cellDelta = Math.round(deltaX / (baseCellSize * scale));

                    if (cellDelta !== 0) {
                        // Get the two specific universes
                        const leftUni = getUniverse(draggingBoundary.leftURow, draggingBoundary.leftUCol);
                        const rightUni = getUniverse(draggingBoundary.rightURow, draggingBoundary.rightUCol);

                        // Adjust only these two universes with equal and opposite deltas
                        if (leftUni && rightUni) {
                            // Calculate the actual delta that can be applied (constrained by minimums)
                            let actualDelta;
                            if (cellDelta > 0) {
                                // Dragging right: left grows, right shrinks
                                // Constraint: right can shrink by at most (rightUni.cols - 1)
                                actualDelta = Math.min(cellDelta, rightUni.cols - 1);
                            } else {
                                // Dragging left: left shrinks, right grows
                                // Constraint: left can shrink by at most (leftUni.cols - 1)
                                actualDelta = Math.max(cellDelta, -(leftUni.cols - 1));
                            }

                            // Apply equal and opposite changes to maintain shared boundary
                            leftUni.cols += actualDelta;
                            rightUni.cols -= actualDelta;

                            dragStartX = mouseX;
                            universeGrid.showCellText = false; // Hide text during adjustment
                            updatePreview();
                        }
                    }
                } else if (draggingBoundary.type === 'horizontal') {
                    const deltaY = mouseY - dragStartY;
                    const cellDelta = Math.round(deltaY / (baseCellSize * scale));

                    if (cellDelta !== 0) {
                        // Get only the two specific universes at this boundary segment
                        const topUni = getUniverse(draggingBoundary.topURow, draggingBoundary.topUCol);
                        const bottomUni = getUniverse(draggingBoundary.bottomURow, draggingBoundary.bottomUCol);

                        // Adjust only these two universes with equal and opposite deltas
                        if (topUni && bottomUni) {
                            // Calculate the actual delta that can be applied (constrained by minimums)
                            let actualDelta;
                            if (cellDelta > 0) {
                                // Dragging down: top grows, bottom shrinks
                                // Constraint: bottom can shrink by at most (bottomUni.rows - 1)
                                actualDelta = Math.min(cellDelta, bottomUni.rows - 1);
                            } else {
                                // Dragging up: top shrinks, bottom grows
                                // Constraint: top can shrink by at most (topUni.rows - 1)
                                actualDelta = Math.max(cellDelta, -(topUni.rows - 1));
                            }

                            // Apply equal and opposite changes to maintain shared boundary
                            topUni.rows += actualDelta;
                            bottomUni.rows -= actualDelta;

                            dragStartY = mouseY;
                            universeGrid.showCellText = false; // Hide text during adjustment
                            updatePreview();
                        }
                    }
                }
            } else if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                panX += deltaX;
                panY += deltaY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updatePreview();
            } else {
                // Update cursor based on position
                const boundary = detectBoundaryAtPosition(mouseX, mouseY);
                if (boundary) {
                    canvas.style.cursor = boundary.type === 'vertical' ? 'ew-resize' : 'ns-resize';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        });

        canvas.addEventListener('mouseup', function() {
            draggingBoundary = null;
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function() {
            draggingBoundary = null;
            isDragging = false;
            canvas.style.cursor = 'grab';
            
            // Reset crosshair position when mouse leaves canvas
            currentMouseX = -1;
            currentMouseY = -1;
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair) {
                updatePreview();
            }
        });
        
        // Edit cell fields on double-click
        let editingCell = null;
        let editDialog = null;
        
        // Parse cell content to extract values
        function parseCellContent(cellValue) {
            const lines = cellValue ? cellValue.split('\n') : [];
            let index = '';
            let universe = '';
            let box = '';
            let note = '';
            
            // Check if using new & format
            const hasNewFormat = lines.some(line => line.trim().startsWith('&'));
            
            if (hasNewFormat) {
                // Parse new format: &value, &Uvalue, &Bvalue, &?value
                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('&')) {
                        const content = trimmed.substring(1); // Remove &
                        if (content.startsWith('U')) {
                            universe = content.substring(1);
                        } else if (content.startsWith('B')) {
                            box = content.substring(1);
                        } else if (content.startsWith('?')) {
                            note = content.substring(1);
                        } else {
                            // First & without prefix is the index
                            if (!index) {
                                // Remove dot if present
                                index = content.replace(/‚óè\s*/g, '').replace(/\s*‚óè/g, '').trim();
                            }
                        }
                    }
                });
            } else {
                // Parse old format
                if (lines.length > 0) {
                    // First line might have index or column number
                    const firstLine = lines[0].trim();
                    // Remove dot if present
                    const cleanFirst = firstLine.replace(/‚óè\s*/g, '').replace(/\s*‚óè/g, '').trim();
                    index = cleanFirst;
                }
                
                if (lines.length > 1) {
                    // Second line has universe and box (e.g., "U6-B10" or "U6-B")
                    const secondLine = lines[1].trim();
                    const universeMatch = secondLine.match(/U(\d+)/);
                    if (universeMatch) {
                        universe = universeMatch[1];
                    }
                    const boxMatch = secondLine.match(/B(\d+)/);
                    if (boxMatch) {
                        box = boxMatch[1];
                    } else if (secondLine.includes('B') && !boxMatch) {
                        box = ''; // Just "B" without number
                    }
                }
                
                if (lines.length > 2) {
                    // Third line or beyond might have notes
                    note = lines.slice(2).join('\n').trim();
                }
            }
            
            return { index, universe, box, note };
        }
        
        function createEditDialog(x, y, cellData, cellKey) {
            // Remove existing dialog if any
            if (editDialog) {
                editDialog.remove();
            }
            
            // Create dialog container
            editDialog = document.createElement('div');
            editDialog.style.position = 'fixed';
            editDialog.style.left = x + 'px';
            editDialog.style.top = y + 'px';
            editDialog.style.width = '200px';
            editDialog.style.padding = '12px';
            editDialog.style.fontSize = '12px';
            editDialog.style.zIndex = '10000';
            editDialog.style.border = '2px solid #667eea';
            editDialog.style.borderRadius = '6px';
            editDialog.style.background = 'rgba(44, 62, 80, 0.95)';
            editDialog.style.backdropFilter = 'blur(10px)';
            editDialog.style.color = 'white';
            editDialog.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
            
            // Create form
            const form = document.createElement('div');
            form.style.display = 'flex';
            form.style.flexDirection = 'column';
            form.style.gap = '8px';
            
            // Title showing cell ID
            const title = document.createElement('div');
            title.style.textAlign = 'center';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '8px';
            title.style.padding = '4px';
            title.style.background = 'rgba(102, 126, 234, 0.3)';
            title.style.borderRadius = '4px';
            title.textContent = `Cell: ${cellKey || 'unknown'}`;
            form.appendChild(title);
            
            // Index field (#)
            const indexGroup = document.createElement('div');
            indexGroup.style.display = 'flex';
            indexGroup.style.alignItems = 'center';
            indexGroup.style.gap = '6px';
            const indexLabel = document.createElement('label');
            indexLabel.textContent = '&';
            indexLabel.style.minWidth = '20px';
            indexLabel.style.color = '#aaa';
            const indexSymbol = document.createElement('span');
            indexSymbol.textContent = '#';
            indexSymbol.style.minWidth = '15px';
            indexSymbol.style.color = '#667eea';
            const indexInput = document.createElement('input');
            indexInput.type = 'text';
            indexInput.value = cellData.index || '';
            indexInput.placeholder = '1-20';
            indexInput.style.flex = '1';
            indexInput.style.padding = '4px';
            indexInput.style.border = '1px solid #444';
            indexInput.style.borderRadius = '3px';
            indexInput.style.background = 'rgba(255, 255, 255, 0.1)';
            indexInput.style.color = 'white';
            indexInput.id = 'editIndex';
            indexGroup.appendChild(indexLabel);
            indexGroup.appendChild(indexSymbol);
            indexGroup.appendChild(indexInput);
            
            // Universe field (U)
            const universeGroup = document.createElement('div');
            universeGroup.style.display = 'flex';
            universeGroup.style.alignItems = 'center';
            universeGroup.style.gap = '6px';
            const universeLabel = document.createElement('label');
            universeLabel.textContent = '&';
            universeLabel.style.minWidth = '20px';
            universeLabel.style.color = '#aaa';
            const universeSymbol = document.createElement('span');
            universeSymbol.textContent = 'U';
            universeSymbol.style.minWidth = '15px';
            universeSymbol.style.color = '#667eea';
            const universeInput = document.createElement('input');
            universeInput.type = 'text';
            universeInput.value = cellData.universe || '';
            universeInput.placeholder = 'Universe';
            universeInput.style.flex = '1';
            universeInput.style.padding = '4px';
            universeInput.style.border = '1px solid #444';
            universeInput.style.borderRadius = '3px';
            universeInput.style.background = 'rgba(255, 255, 255, 0.1)';
            universeInput.style.color = 'white';
            universeInput.id = 'editUniverse';
            universeGroup.appendChild(universeLabel);
            universeGroup.appendChild(universeSymbol);
            universeGroup.appendChild(universeInput);
            
            // Box field (B)
            const boxGroup = document.createElement('div');
            boxGroup.style.display = 'flex';
            boxGroup.style.alignItems = 'center';
            boxGroup.style.gap = '6px';
            const boxLabel = document.createElement('label');
            boxLabel.textContent = '&';
            boxLabel.style.minWidth = '20px';
            boxLabel.style.color = '#aaa';
            const boxSymbol = document.createElement('span');
            boxSymbol.textContent = 'B';
            boxSymbol.style.minWidth = '15px';
            boxSymbol.style.color = '#667eea';
            const boxInput = document.createElement('input');
            boxInput.type = 'text';
            boxInput.value = cellData.box || '';
            boxInput.placeholder = 'Box';
            boxInput.style.flex = '1';
            boxInput.style.padding = '4px';
            boxInput.style.border = '1px solid #444';
            boxInput.style.borderRadius = '3px';
            boxInput.style.background = 'rgba(255, 255, 255, 0.1)';
            boxInput.style.color = 'white';
            boxInput.id = 'editBox';
            boxGroup.appendChild(boxLabel);
            boxGroup.appendChild(boxSymbol);
            boxGroup.appendChild(boxInput);
            
            // Note field (?)
            const noteGroup = document.createElement('div');
            noteGroup.style.display = 'flex';
            noteGroup.style.alignItems = 'center';
            noteGroup.style.gap = '6px';
            const noteLabel = document.createElement('label');
            noteLabel.textContent = '&';
            noteLabel.style.minWidth = '20px';
            noteLabel.style.color = '#aaa';
            const noteSymbol = document.createElement('span');
            noteSymbol.textContent = '?';
            noteSymbol.style.minWidth = '15px';
            noteSymbol.style.color = '#667eea';
            const noteInput = document.createElement('input');
            noteInput.type = 'text';
            noteInput.value = cellData.note || '';
            noteInput.placeholder = 'Note';
            noteInput.style.flex = '1';
            noteInput.style.padding = '4px';
            noteInput.style.border = '1px solid #444';
            noteInput.style.borderRadius = '3px';
            noteInput.style.background = 'rgba(255, 255, 255, 0.1)';
            noteInput.style.color = 'white';
            noteInput.id = 'editNote';
            noteGroup.appendChild(noteLabel);
            noteGroup.appendChild(noteSymbol);
            noteGroup.appendChild(noteInput);
            
            // Buttons
            const buttonGroup = document.createElement('div');
            buttonGroup.style.display = 'flex';
            buttonGroup.style.gap = '6px';
            buttonGroup.style.marginTop = '4px';
            
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.flex = '1';
            saveBtn.style.padding = '6px';
            saveBtn.style.background = '#667eea';
            saveBtn.style.color = 'white';
            saveBtn.style.border = 'none';
            saveBtn.style.borderRadius = '3px';
            saveBtn.style.cursor = 'pointer';
            saveBtn.onclick = finishEditing;
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.flex = '1';
            cancelBtn.style.padding = '6px';
            cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            cancelBtn.style.color = 'white';
            cancelBtn.style.border = '1px solid #444';
            cancelBtn.style.borderRadius = '3px';
            cancelBtn.style.cursor = 'pointer';
            cancelBtn.onclick = cancelEditing;
            
            buttonGroup.appendChild(saveBtn);
            buttonGroup.appendChild(cancelBtn);
            
            form.appendChild(indexGroup);
            form.appendChild(universeGroup);
            form.appendChild(boxGroup);
            form.appendChild(noteGroup);
            form.appendChild(buttonGroup);
            editDialog.appendChild(form);
            
            document.body.appendChild(editDialog);
            indexInput.focus();
            indexInput.select();
            
            // Handle Escape key
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    cancelEditing();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }
        
        // Store custom cell data
        let cellCustomData = new Map(); // key: "row,col", value: {index, universe, box, note}
        
        // Track manually created points (not from CSV)
        let createdPoints = new Set(); // Set of cellKeys that have manually created points
        
        // Create a new point for a cell based on grid structure
        // Store in CSV coordinate format so it transforms with scale/offset like original points
        function createPointForCell(cellRow, cellCol, cellKey) {
            const baseCellSize = 60;
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
            
            // Check if point cloud is loaded (need bounds for coordinate conversion)
            if (!pointCloudLoaded || !pointCloudBounds) {
                console.warn('createPointForCell: No point cloud loaded, cannot create point');
                return;
            }
            
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;
            
            // Determine the stagger pattern by analyzing existing points in the same row
            // Find points in the same grid row to determine if this row is left or right staggered
            let isLeftStagger = true; // Default
            let foundStaggerPattern = false;
            
            // Look for existing non-created points to determine stagger pattern
            for (const point of pointCloudData) {
                if (point.isCreated) continue; // Skip created points
                
                // Calculate this point's grid row
                const relativeY = point.y - pointCloudBounds.minY;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                const gridPixelYWithOffset = gridPixelYFlipped + pointOffsetY;
                const pointGridRow = Math.floor(gridPixelYWithOffset / baseCellSize);
                
                if (pointGridRow === cellRow) {
                    // Found a point in the same row - check its X position within the cell
                    const relativeX = point.x - pointCloudBounds.minX;
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    const pointGridCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                    
                    // Position within cell (0-1 range)
                    const posInCell = (gridPixelXWithOffset / baseCellSize) - pointGridCol;
                    
                    // If position is < 0.5, it's left-staggered; if >= 0.5, it's right-staggered
                    isLeftStagger = posInCell < 0.5;
                    foundStaggerPattern = true;
                    console.log('createPointForCell: Found stagger pattern from point in same row:', {
                        pointGridRow, pointGridCol, posInCell, isLeftStagger
                    });
                    break;
                }
            }
            
            // If no point found in same row, look at adjacent rows to extrapolate
            if (!foundStaggerPattern) {
                for (const point of pointCloudData) {
                    if (point.isCreated) continue;
                    
                    const relativeY = point.y - pointCloudBounds.minY;
                    const gridPixelY = relativeY * baseCellSize * pointScale;
                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                    const gridPixelYWithOffset = gridPixelYFlipped + pointOffsetY;
                    const pointGridRow = Math.floor(gridPixelYWithOffset / baseCellSize);
                    
                    // Get this point's stagger
                    const relativeX = point.x - pointCloudBounds.minX;
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    const pointGridCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                    const posInCell = (gridPixelXWithOffset / baseCellSize) - pointGridCol;
                    const pointIsLeftStagger = posInCell < 0.5;
                    
                    // Calculate row difference - stagger alternates each row
                    const rowDiff = Math.abs(cellRow - pointGridRow);
                    if (rowDiff % 2 === 0) {
                        // Same stagger pattern
                        isLeftStagger = pointIsLeftStagger;
                    } else {
                        // Opposite stagger pattern
                        isLeftStagger = !pointIsLeftStagger;
                    }
                    foundStaggerPattern = true;
                    console.log('createPointForCell: Extrapolated stagger from row', pointGridRow, 'to row', cellRow, ':', {
                        rowDiff, pointIsLeftStagger, isLeftStagger
                    });
                    break;
                }
            }
            
            // Calculate target X position with stagger
            // Left stagger: point is left of center (xOffset ~= 0.25)
            // Right stagger: point is right of center (xOffset ~= 0.75)
            const xOffset = isLeftStagger ? 0.25 : 0.75;
            const targetGridPixelX = (cellCol + xOffset) * baseCellSize;
            const targetGridPixelY = (cellRow + 0.5) * baseCellSize;
            
            // Reverse the transformation to get CSV coordinates
            const gridPixelX = targetGridPixelX - pointOffsetX;
            const relativeX = gridPixelX / (baseCellSize * pointScale);
            const csvX = relativeX + pointCloudBounds.minX;
            
            const gridPixelYFlipped = targetGridPixelY - pointOffsetY;
            const gridPixelY = (csvHeight * baseCellSize * pointScale) - gridPixelYFlipped;
            const relativeY = gridPixelY / (baseCellSize * pointScale);
            const csvY = relativeY + pointCloudBounds.minY;
            
            console.log('createPointForCell:', {
                cellRow, cellCol, cellKey,
                isLeftStagger, xOffset,
                targetGridPixel: { x: targetGridPixelX, y: targetGridPixelY },
                csvCoords: { x: csvX.toFixed(2), y: csvY.toFixed(2) },
                transform: { scale: pointScale, offsetX: pointOffsetX, offsetY: pointOffsetY }
            });
            
            // Add the new point to pointCloudData in CSV coordinate format
            const newPoint = {
                x: csvX,
                y: csvY,
                isCreated: true,
                cellKey: cellKey
            };
            
            pointCloudData.push(newPoint);
            createdPoints.add(cellKey);
            
            console.log('Created new point:', newPoint, 'Total points:', pointCloudData.length);
        }
        
        // Remove a manually created point for a cell
        function removeCreatedPointForCell(cellKey) {
            if (!createdPoints.has(cellKey)) return;
            
            // Find and remove the point with this cellKey
            const index = pointCloudData.findIndex(p => p.isCreated && p.cellKey === cellKey);
            if (index !== -1) {
                pointCloudData.splice(index, 1);
                createdPoints.delete(cellKey);
                console.log('Removed created point for cell:', cellKey, 'Total points:', pointCloudData.length);
            }
        }
        
        function finishEditing() {
            if (!editingCell || !editDialog) return;
            
            const indexInput = document.getElementById('editIndex');
            const universeInput = document.getElementById('editUniverse');
            const boxInput = document.getElementById('editBox');
            const noteInput = document.getElementById('editNote');
            
            if (!indexInput || !universeInput || !boxInput || !noteInput) {
                cancelEditing();
                return;
            }
            
            // Use the actual cell key (based on point position) if available
            const cellKey = editingCell.actualCellKey || `${editingCell.cellRow},${editingCell.cellCol}`;
            
            console.log('finishEditing:', {
                clickedCell: `${editingCell.cellRow},${editingCell.cellCol}`,
                actualCellKey: editingCell.actualCellKey,
                usedCellKey: cellKey,
                hasPoint: editingCell.hasPoint
            });
            
            // Check if this cell has a point - if not, warn about B number
            if (!editingCell.hasPoint && boxInput.value.trim()) {
                console.warn('Cell has no point - B number will not create a black dot');
            }
            
            // Get values
            const index = indexInput.value.trim();
            const universe = universeInput.value.trim();
            const box = boxInput.value.trim();
            const note = noteInput.value.trim();
            
            // Store custom data if any field has a value
            // If B is empty but other fields have values, we store box: '' to mark it as "explicitly no box"
            if (index || universe || box || note) {
                // Store custom data - include box even if empty string to mark it as "explicitly no box"
                cellCustomData.set(cellKey, { index, universe, box: box, note });
                
                // Update box number mapping if box is set
                if (box) {
                    const boxNum = parseInt(box);
                    if (!isNaN(boxNum) && boxNum > 0) {
                        cellToBoxNumber.set(cellKey, boxNum);
                        
                        // If this cell had no point and a B number was added, CREATE a new point
                        if (!editingCell.hasPoint) {
                            createPointForCell(editingCell.cellRow, editingCell.cellCol, cellKey);
                        }
                    } else {
                        // Invalid box number, clear it
                        cellToBoxNumber.delete(cellKey);
                    }
                } else {
                    // B is explicitly empty - clear box assignment and don't auto-assign
                    cellToBoxNumber.delete(cellKey);
                    
                    // If the cell had a point that was CREATED (not from CSV), remove it
                    removeCreatedPointForCell(cellKey);
                }
            } else {
                // Clear all custom data if all fields are empty
                cellCustomData.delete(cellKey);
                cellToBoxNumber.delete(cellKey);
                
                // Remove any created point
                removeCreatedPointForCell(cellKey);
            }
            
            // Recalculate cable groups to update green dot positions and groupings
            if (pointCloudLoaded && pointCloudData.length > 0) {
                calculateCableGroups();
            }
            
            // Redraw to show updated cell content
            updatePreview();
            
            cancelEditing();
        }
        
        function cancelEditing() {
            if (editDialog) {
                editDialog.remove();
                editDialog = null;
            }
            editingCell = null;
        }
        
        // Detect which cell was clicked
        function getCellAtPosition(mouseX, mouseY) {
            const canvas = document.getElementById('gridCanvas');
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;
            
            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;
            
            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;
            
            // Convert mouse position to grid coordinates
            const gridX = (mouseX - offsetX) / scale;
            const gridY = (mouseY - offsetY) / scale;
            
            const cellCol = Math.floor(gridX / baseCellSize);
            const cellRow = Math.floor(gridY / baseCellSize);
            
            const cellID = `${cellRow},${cellCol}`;
            console.log(`%c DETECTED CELL: ${cellID} `, 'background: #0066ff; color: white; font-size: 14px; padding: 4px;');
            console.log('getCellAtPosition details:', {
                cellID: cellID,
                mouseX: mouseX.toFixed(0), mouseY: mouseY.toFixed(0),
                canvasSize: { w: canvas.width, h: canvas.height },
                offset: { x: offsetX.toFixed(0), y: offsetY.toFixed(0) },
                scale: scale.toFixed(4),
                gridPos: { x: gridX.toFixed(1), y: gridY.toFixed(1) },
                posInCell: { 
                    x: ((gridX % baseCellSize) / baseCellSize * 100).toFixed(0) + '%',
                    y: ((gridY % baseCellSize) / baseCellSize * 100).toFixed(0) + '%'
                },
                cellBounds: { 
                    left: (offsetX + cellCol * baseCellSize * scale).toFixed(0),
                    right: (offsetX + (cellCol + 1) * baseCellSize * scale).toFixed(0),
                    top: (offsetY + cellRow * baseCellSize * scale).toFixed(0),
                    bottom: (offsetY + (cellRow + 1) * baseCellSize * scale).toFixed(0)
                }
            });
            
            if (cellCol >= 0 && cellCol < totalCols && cellRow >= 0 && cellRow < totalRows) {
                const cellUniverse = getCellUniverse(cellCol, cellRow);
                if (cellUniverse) {
                    return {
                        cellCol: cellCol,
                        cellRow: cellRow,
                        universeNum: cellUniverse.universeNum,
                        screenX: offsetX + (cellCol * baseCellSize * scale),
                        screenY: offsetY + (cellRow * baseCellSize * scale)
                    };
                }
            }
            return null;
        }
        
        // Find the point that is visually closest to the clicked screen position
        // Returns { pointIndex, cellKey } or null if no point near the click
        function findPointAtScreenPosition(screenX, screenY, gridOffsetX, gridOffsetY, gridScale) {
            if (!pointCloudLoaded || pointCloudData.length === 0) {
                console.log('findPointAtScreenPosition: No point cloud loaded');
                return null;
            }
            
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 0);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 0);
            const baseCellSize = 60;
            const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;
            
            // Find the point closest to the clicked screen position
            let closestPoint = null;
            let closestDistance = Infinity;
            const maxDistance = baseCellSize * gridScale; // Max distance = one cell size in screen pixels
            
            for (let i = 0; i < pointCloudData.length; i++) {
                const point = pointCloudData[i];
                const relativeX = point.x - pointCloudBounds.minX;
                const relativeY = point.y - pointCloudBounds.minY;
                
                const gridPixelX = relativeX * baseCellSize * pointScale;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                
                const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;
                
                // Calculate screen position (same as in drawPointCloud)
                const px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                const py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);
                
                // Distance from clicked position to this point's screen position
                const dist = Math.sqrt(Math.pow(px - screenX, 2) + Math.pow(py - screenY, 2));
                
                if (dist < closestDistance && dist < maxDistance) {
                    closestDistance = dist;
                    
                    // Calculate the point's cell key (same as elsewhere)
                    const pointCellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                    const pointCellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);
                    
                    closestPoint = {
                        pointIndex: i,
                        cellKey: `${pointCellRow},${pointCellCol}`,
                        screenX: px,
                        screenY: py,
                        distance: dist
                    };
                }
            }
            
            if (closestPoint) {
                console.log(`findPointAtScreenPosition: Found point ${closestPoint.pointIndex} at screen (${closestPoint.screenX.toFixed(0)}, ${closestPoint.screenY.toFixed(0)}), distance: ${closestPoint.distance.toFixed(0)}px, cellKey: ${closestPoint.cellKey}`);
                return {
                    pointIndex: closestPoint.pointIndex,
                    cellKey: closestPoint.cellKey
                };
            }
            
            console.log(`findPointAtScreenPosition: No point found within ${maxDistance.toFixed(0)}px of click at (${screenX.toFixed(0)}, ${screenY.toFixed(0)})`);
            return null;
        }
        
        // Legacy function - kept for compatibility but now uses screen-based search
        function findPointInCell(cellRow, cellCol) {
            console.log(`findPointInCell: Delegating to screen-based search for cell (${cellRow}, ${cellCol})`);
            // This will be called without screen coordinates, so return null
            // The actual search happens in the double-click handler
            return null;
        }
        
        canvas.addEventListener('dblclick', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const rawMouseX = e.clientX - rect.left;
            const rawMouseY = e.clientY - rect.top;
            const mouseX = rawMouseX * cssToCanvasX;
            const mouseY = rawMouseY * cssToCanvasY;
            
            console.log('dblclick raw:', {
                clientX: e.clientX, clientY: e.clientY,
                rectLeft: rect.left.toFixed(0), rectTop: rect.top.toFixed(0),
                rectWidth: rect.width.toFixed(0), rectHeight: rect.height.toFixed(0),
                canvasWidth: canvas.width, canvasHeight: canvas.height,
                cssToCanvas: { x: cssToCanvasX.toFixed(3), y: cssToCanvasY.toFixed(3) },
                rawMouse: { x: rawMouseX.toFixed(0), y: rawMouseY.toFixed(0) },
                scaledMouse: { x: mouseX.toFixed(0), y: mouseY.toFixed(0) }
            });
            
            const cell = getCellAtPosition(mouseX, mouseY);
            if (cell) {
                editingCell = cell;
                
                // Calculate the grid transform parameters (same as in drawGridPreview)
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;
                const availableWidth = canvas.width * 0.9;
                const availableHeight = canvas.height * 0.9;
                const scaleX = availableWidth / gridPixelWidth;
                const scaleY = availableHeight / gridPixelHeight;
                const baseScale = Math.min(scaleX, scaleY);
                const currentScale = baseScale * zoom;
                
                const gridWidth = gridPixelWidth * currentScale;
                const gridHeight = gridPixelHeight * currentScale;
                const baseOffsetX = (canvas.width - gridWidth) / 2;
                const baseOffsetY = (canvas.height - gridHeight) / 2;
                const gridOffsetX = baseOffsetX + panX;
                const gridOffsetY = baseOffsetY + panY;
                
                // Find point using screen coordinates (accounts for zoom, pan, and point transform)
                const pointInfo = findPointAtScreenPosition(mouseX, mouseY, gridOffsetX, gridOffsetY, currentScale);
                
                console.log('Double-click on cell:', {
                    screenPos: { x: mouseX.toFixed(0), y: mouseY.toFixed(0) },
                    visualCellRow: cell.cellRow,
                    visualCellCol: cell.cellCol,
                    universeNum: cell.universeNum,
                    gridTransform: { offsetX: gridOffsetX.toFixed(0), offsetY: gridOffsetY.toFixed(0), scale: currentScale.toFixed(3) },
                    pointFound: pointInfo !== null,
                    pointCellKey: pointInfo ? pointInfo.cellKey : 'none'
                });
                
                // Use the clicked cell's key (NOT the point's key - we want to edit the cell we clicked on)
                const clickedCellKey = `${cell.cellRow},${cell.cellCol}`;
                const pointCellKey = pointInfo ? pointInfo.cellKey : null;
                
                // IMPORTANT: Use the CLICKED cell's key, not the point's key
                // The point may be associated with a different cell due to offset/scale
                const cellKey = clickedCellKey;
                
                console.log('%c CELL KEY DECISION ', 'background: #ff6600; color: white; font-size: 12px;', {
                    clickedCellKey: clickedCellKey,
                    pointCellKey: pointCellKey,
                    usingCellKey: cellKey,
                    note: pointCellKey && pointCellKey !== clickedCellKey ? 'MISMATCH: point in different cell!' : 'OK'
                });
                
                // Store the actual cell key for use in finishEditing
                editingCell.actualCellKey = cellKey;
                editingCell.hasPoint = pointInfo !== null && pointInfo.cellKey === clickedCellKey;
                
                let cellData = cellCustomData.get(cellKey);
                
                // If no custom data, parse from current cell content or use defaults
                if (!cellData) {
                    // Get the cell's universe info
                    const cellUniverse = getCellUniverse(cell.cellCol, cell.cellRow);
                    if (cellUniverse) {
                        const colInUniverse = cellUniverse.cellInUniverseCol;
                        const rowInUniverse = cellUniverse.cellInUniverseRow;
                        const universeNum = cellUniverse.universeNum;
                        const currentBoxNum = cellToBoxNumber.get(cellKey);
                        
                        // Get the current cell label to parse the first line (index)
                        const currentLabel = generateCellLabel(rowInUniverse + 1, colInUniverse, universeNum, currentBoxNum, cell.cellRow, cell.cellCol);
                        const lines = currentLabel.split('\n');
                        const firstLine = lines[0] ? lines[0].trim() : '';
                        // Remove dot if present
                        const indexValue = firstLine.replace(/‚óè\s*/g, '').replace(/\s*‚óè/g, '').trim();
                        
                        // Try to parse existing cell format
                        cellData = {
                            index: indexValue || (colInUniverse + 1).toString(), // Use first line or fallback to column
                            universe: universeNum.toString(),
                            box: currentBoxNum ? currentBoxNum.toString() : '',
                            note: ''
                        };
                    } else {
                        cellData = { index: '', universe: '', box: '', note: '' };
                    }
                }
                
                // Position dialog near the cell (reuse grid transform values from above)
                const cellScreenX = gridOffsetX + (cell.cellCol * baseCellSize * currentScale);
                const cellScreenY = gridOffsetY + (cell.cellRow * baseCellSize * currentScale);
                
                // Position dialog at center of cell, offset to avoid covering it
                const dialogX = rect.left + cellScreenX + (baseCellSize * currentScale) / 2 - 100;
                const dialogY = rect.top + cellScreenY + (baseCellSize * currentScale) / 2 - 100;
                
                createEditDialog(dialogX, dialogY, cellData, cellKey);
            }
        });
    </script>
</body>
</html>


