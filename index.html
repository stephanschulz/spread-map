<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Spread-Map Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #2c3e50;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #gridCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #gridCanvas:active {
            cursor: grabbing;
        }

        .zoom-controls {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-label {
            flex: 1;
            text-align: center;
            font-size: 11px;
            color: #aaa;
        }

        .container {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 260px;
            padding: 10px;
            z-index: 1000;
            color: white;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        .container::-webkit-scrollbar {
            width: 6px;
        }

        .container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .gui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            margin-bottom: 3px;
        }

        .gui-header:hover .toggle-btn {
            background: rgba(255, 255, 255, 0.2);
        }

        h1 {
            color: #fff;
            margin-bottom: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 300;
        }

        .toggle-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .gui-content {
            transition: max-height 0.3s ease, opacity 0.2s ease;
            overflow: hidden;
        }

        .container.collapsed .gui-content {
            max-height: 0 !important;
            opacity: 0;
            pointer-events: none;
        }

        .container.collapsed {
            overflow: hidden;
        }

        .container.collapsed .subtitle {
            display: none;
        }

        .subtitle {
            color: #aaa;
            margin-bottom: 8px;
            font-size: 10px;
        }

        .form-group {
            margin-bottom: 8px;
        }

        label {
            display: block;
            color: #ccc;
            font-weight: 400;
            margin-bottom: 3px;
            font-size: 10px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
        }

        input[type="number"] {
            width: 100%;
            padding: 5px 6px;
            border: 1px solid #444;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
        }

        .help-text {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }

        .preview-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            padding: 6px 8px;
            margin: 6px 0;
        }

        .preview-title {
            font-weight: 400;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-info {
            color: #ccc;
            font-size: 10px;
            line-height: 1.5;
        }

        .preview-info div {
            margin: 3px 0;
        }

        .preview-info strong {
            color: #aaa;
            font-weight: 400;
            display: inline-block;
            min-width: 60px;
        }

        .preview-value {
            color: #667eea;
            font-weight: 600;
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
        }

        button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #667eea;
            color: white;
        }

        button:hover {
            background: #5568d3;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 12px;
            color: #667eea;
            font-size: 11px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 6px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid rgba(255, 50, 50, 0.5);
            color: #ff8888;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            display: none;
            font-size: 11px;
        }

        .error.show {
            display: block;
        }

        /* Scrollbar styling for dark theme */
        .container::-webkit-scrollbar {
            width: 6px;
        }

        .container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .section-title {
            font-size: 10px;
            font-weight: 400;
            color: #aaa;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slider-row input[type="range"] {
            flex: 1;
        }

        .reset-btn {
            padding: 4px 8px;
            font-size: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ccc;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>

<body>
    <canvas id="gridCanvas"></canvas>

    <div class="container" id="guiContainer">
        <div class="gui-header" id="guiHeader">
            <h1>üåå Spread-Map</h1>
            <button type="button" class="toggle-btn" id="guiToggle" title="Toggle GUI">‚ñº</button>
        </div>
        <p class="subtitle">Generate custom spreadsheet maps</p>

        <div class="gui-content" id="guiContent">
            <form id="mapForm">
                <div class="section-title">Universe Dimensions</div>
                <div class="form-group">
                    <div class="input-row">
                        <div class="input-wrapper">
                            <label>Columns</label>
                            <input type="number" id="cols" name="cols" value="20" min="1" max="50" required>
                            <div class="help-text">1-20 left to right</div>
                        </div>
                        <div class="input-wrapper">
                            <label>Rows</label>
                            <input type="number" id="rows" name="rows" value="10" min="1" max="50" required>
                            <div class="help-text">B1, B2, B3...</div>
                        </div>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section-title">Grid Layout</div>
                <div class="form-group">
                    <div class="input-row">
                        <div class="input-wrapper">
                            <label>Horizontal</label>
                            <input type="number" id="universes_h" name="universes_h" value="6" min="1" max="20"
                                required>
                            <div class="help-text">universes</div>
                        </div>
                        <div class="input-wrapper">
                            <label>Vertical</label>
                            <input type="number" id="universes_v" name="universes_v" value="5" min="1" max="20"
                                required>
                            <div class="help-text">universes</div>
                        </div>
                    </div>
                </div>

                <button type="button" id="applyGridBtn"
                    style="width: 100%; margin-top: 8px; padding: 6px; background: #667eea; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; font-weight: 500;">
                    Apply Grid Changes
                </button>

                <div class="preview-box" id="previewBox">
                    <div class="preview-title">üìä Stats</div>
                    <div class="preview-info" id="previewInfo">
                        <div><strong>Universes:</strong> <span class="preview-value" id="totalUniverses">-</span></div>
                        <div><strong>Grid:</strong> <span class="preview-value" id="gridSize">-</span></div>
                        <div><strong>Cells per Universe:</strong> <span class="preview-value"
                                id="cellsPerUniverse">-</span></div>
                        <div><strong>Total Cells:</strong> <span class="preview-value" id="totalCells">-</span></div>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section-title">Display Options</div>
                <div class="form-group">
                    <div class="input-wrapper" style="width: 100%;">
                        <label style="display: block;">Spread-Map Alpha: <span id="mapAlphaValue">100%</span></label>
                        <input type="range" id="mapAlpha" min="0" max="100" step="1" value="100" style="width: 100%;">
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="showCableGroups" checked>
                            Show Cable Groups (20)
                        </label>
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="showPointCloud" checked>
                            Show Points
                        </label>
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="showRowColHeaders" checked>
                            Show Row/Column Headers
                        </label>
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="showCrosshair">
                            Show Crosshair
                        </label>
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 12px;">
                        <label style="display: block; margin-bottom: 4px;">Load Spreadsheet:</label>
                        <input type="file" id="csvFileInput" accept=".csv,.xlsx" style="font-size: 11px; width: 100%;">
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label style="display: block;">Point Scale: <span id="pointScaleValue">1.0x</span></label>
                        <div class="slider-row">
                            <input type="range" id="pointScale" min="0.01" max="10" step="0.01" value="1">
                            <button type="button" class="reset-btn" id="resetPointScale"
                                title="Reset to auto-detected pitch">‚Üª</button>
                        </div>
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label style="display: block;">Point Size: <span id="pointSizeValue">20px</span></label>
                        <input type="range" id="pointSize" min="1" max="20" step="1" value="20" style="width: 100%;">
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label style="display: block;">Point Offset X: <span id="pointOffsetXValue">17</span></label>
                        <input type="range" id="pointOffsetX" min="-500" max="500" step="1" value="17"
                            style="width: 100%;">
                    </div>
                    <div class="input-wrapper" style="width: 100%; margin-top: 8px;">
                        <label style="display: block;">Point Offset Y: <span id="pointOffsetYValue">30</span></label>
                        <input type="range" id="pointOffsetY" min="-500" max="500" step="1" value="30"
                            style="width: 100%;">
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section-title">View Controls</div>
                <div class="zoom-controls">
                    <button type="button" class="zoom-btn" id="zoomOut">‚àí</button>
                    <div class="zoom-label" id="zoomLevel">100%</div>
                    <button type="button" class="zoom-btn" id="zoomIn">+</button>
                </div>
                <div style="font-size: 10px; color: #888; text-align: center; margin-top: 4px;">
                    Scroll to zoom ‚Ä¢ Drag to pan<br>
                    Double-click cell to edit B number
                </div>

                <div class="divider"></div>

                <div class="input-wrapper" style="width: 100%; margin-bottom: 10px;">
                    <label>
                        <input type="checkbox" id="exportPDF" checked>
                        Also export PDF
                    </label>
                </div>

                <button type="submit">
                    ‚¨áÔ∏è Generate & Download Excel
                </button>

                <div class="error" id="errorBox"></div>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <div>Generating Excel file...</div>
                </div>

                <div
                    style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); text-align: center;">
                    <a href="https://github.com/stephanschulz/spread-map" target="_blank" rel="noopener noreferrer"
                        style="color: #667eea; text-decoration: none; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="flex-shrink: 0;">
                            <path
                                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
                        </svg>
                        GitHub Repository
                    </a>
                </div>
            </form>
        </div><!-- end gui-content -->
    </div>

    <script>
        // Global state for zoom and pan
        let zoom = 0.8;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Global mouse position for crosshair
        let currentMouseX = -1;
        let currentMouseY = -1;

        // Cache for pre-rendered grid image
        let cachedGridImage = null;
        let cachedGridConfig = null;

        // Point cloud data
        let pointCloudData = [];
        let pointCloudLoaded = false;
        let pointCloudBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let pointCloudPitch = { x: 0, y: 0 }; // Detected pitch/spacing
        let cableGroups = []; // Groups of 20 points with their center points
        let cellToBoxNumber = new Map(); // Maps "row,col" to box number

        // Variable universe grid structure - each universe has independent dimensions
        let universeGrid = {
            universesH: 6,
            universesV: 5,
            // 2D array of universes: universes[uRow][uCol] = {cols, rows}
            universes: [],
            showCellText: true // Show text on initial load
        };

        // Dragging state for boundaries
        let draggingBoundary = null;
        let dragStartX = 0;
        let dragStartY = 0;

        // Custom box positions (for dragged green rectangles)
        // Key: "universeNum-groupInUniverse", Value: { x, y } in grid pixel space
        let customBoxPositions = new Map();
        let draggingBox = null; // { groupIndex, startX, startY }

        // Initialize universe grid with uniform dimensions
        function initializeUniverseGrid(cols, rows, universesH, universesV) {
            universeGrid.universesH = universesH;
            universeGrid.universesV = universesV;
            universeGrid.universes = [];

            // Initialize each universe with independent dimensions
            for (let uRow = 0; uRow < universesV; uRow++) {
                const rowArray = [];
                for (let uCol = 0; uCol < universesH; uCol++) {
                    rowArray.push({
                        cols: cols,
                        rows: rows
                    });
                }
                universeGrid.universes.push(rowArray);
            }

            console.log('Initialized universe grid:', universeGrid);
        }

        // Get universe at specific position
        function getUniverse(uRow, uCol) {
            if (uRow >= 0 && uRow < universeGrid.universesV &&
                uCol >= 0 && uCol < universeGrid.universesH) {
                return universeGrid.universes[uRow][uCol];
            }
            return null;
        }

        // Get total columns for a specific universe
        function getUniverseCols(uRow, uCol) {
            const uni = getUniverse(uRow, uCol);
            return uni ? uni.cols : 0;
        }

        // Get total rows for a specific universe
        function getUniverseRows(uRow, uCol) {
            const uni = getUniverse(uRow, uCol);
            return uni ? uni.rows : 0;
        }

        // Get total columns across all universes (max in any row)
        function getTotalCols() {
            let maxCols = 0;
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                let rowCols = 0;
                for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                    rowCols += getUniverseCols(uRow, uCol);
                }
                maxCols = Math.max(maxCols, rowCols);
            }
            return maxCols;
        }

        // Get total rows across all universes (max in any column)
        function getTotalRows() {
            let maxRows = 0;
            for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                let colRows = 0;
                for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                    colRows += getUniverseRows(uRow, uCol);
                }
                maxRows = Math.max(maxRows, colRows);
            }
            return maxRows;
        }

        // Read and parse Excel file
        function parseExcelFile(arrayBuffer) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array', cellStyles: true });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];

                return { workbook, worksheet };
            } catch (error) {
                console.error('Error parsing Excel file:', error);
                throw new Error('Failed to parse Excel file');
            }
        }

        // Detect if file is a point cloud CSV or exported map
        function detectFileFormat(data, isExcel) {
            if (isExcel) {
                // For Excel, check the header row
                const { worksheet } = data;
                const range = XLSX.utils.decode_range(worksheet['!ref']);

                // Check first row for column headers
                let hasColumnHeaders = false;
                let hasPointCloudHeaders = false;

                for (let C = range.s.c; C <= Math.min(range.s.c + 5, range.e.c); C++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: 0, c: C });
                    const cell = worksheet[cellAddress];
                    if (cell && cell.v) {
                        const value = String(cell.v).trim();
                        if (value.match(/^C\d+$/)) {
                            hasColumnHeaders = true;
                        }
                        if (value === 'ID' || value === 'px' || value === 'py') {
                            hasPointCloudHeaders = true;
                        }
                    }
                }

                return hasColumnHeaders ? 'exported-map' : (hasPointCloudHeaders ? 'point-cloud' : 'unknown');
            } else {
                // For CSV, check the first line
                const firstLine = data.trim().split('\n')[0];
                if (firstLine.includes('ID,px,py') || firstLine.includes('ID,') && firstLine.includes(',px,') && firstLine.includes(',py,')) {
                    return 'point-cloud';
                }
                if (firstLine.match(/C\d+/)) {
                    return 'exported-map';
                }
                return 'unknown';
            }
        }

        // Import exported map - reconstruct grid and points from cell content
        function importExportedMap(mapData) {
            console.log('Importing exported map:', mapData);

            // Update form inputs
            const avgCols = Math.round(mapData.universes[0].reduce((sum, u) => sum + u.cols, 0) / mapData.universesH);
            const avgRows = Math.round(mapData.universes.reduce((sum, row) => sum + row[0].rows, 0) / mapData.universesV);

            document.getElementById('cols').value = avgCols;
            document.getElementById('rows').value = avgRows;
            document.getElementById('universes_h').value = mapData.universesH;
            document.getElementById('universes_v').value = mapData.universesV;

            // Rebuild universe grid
            universeGrid.universesH = mapData.universesH;
            universeGrid.universesV = mapData.universesV;
            universeGrid.universes = mapData.universes;
            universeGrid.showCellText = true; // Show cell text since this is an imported map

            // Import custom cell data from cell content
            cellCustomData.clear();
            if (mapData.customCellData) {
                mapData.customCellData.forEach((value, key) => {
                    cellCustomData.set(key, value);
                });
                console.log('Imported', cellCustomData.size, 'cells with custom data');
            }

            // Import cell-to-box assignments from B numbers in cells
            cellToBoxNumber.clear();
            if (mapData.cellBoxAssignments) {
                mapData.cellBoxAssignments.forEach((boxNum, cellKey) => {
                    cellToBoxNumber.set(cellKey, boxNum);
                });
                console.log('Imported', cellToBoxNumber.size, 'cell-to-box assignments');
            }

            // Import box positions from the "Box-N" cells in the XLSX
            // This ensures green boxes appear in exactly the same positions as in the exported file
            customBoxPositions.clear();
            if (mapData.boxCells && mapData.boxCells.size > 0) {
                const baseCellSize = 60;
                mapData.boxCells.forEach((pos, boxKey) => {
                    // Convert cell position to grid pixel position (cell center)
                    const gridPixelX = (pos.col + 0.5) * baseCellSize;
                    const gridPixelY = (pos.row + 0.5) * baseCellSize;
                    customBoxPositions.set(boxKey, { x: gridPixelX, y: gridPixelY });
                });
                console.log('Imported', customBoxPositions.size, 'box positions from Box-N cells');
                // Debug: log all imported box positions
                customBoxPositions.forEach((pos, key) => {
                    console.log(`  Box position ${key}: row=${Math.floor(pos.y / 60)}, col=${Math.floor(pos.x / 60)}`);
                });
            } else {
                console.log('No box positions found in XLSX, will calculate from group centers');
            }

            console.log('Universe grid rebuilt:', universeGrid);

            // Convert point positions to point cloud data
            pointCloudData = [];
            const baseCellSize = 60;

            if (mapData.points.length > 0) {
                const totalRows = mapData.totalRows;
                const totalCols = mapData.totalCols;

                console.log('Import - grid dimensions:', totalCols, 'cols x', totalRows, 'rows');

                mapData.points.forEach(point => {
                    // Store imported points with their cell positions directly
                    // The render code will detect isImported and place them at cell positions
                    // bypassing the CSV-to-grid transformation entirely

                    // Small stagger offset for visual variety (keeps points within cells)
                    const xStagger = point.leftStagger ? -0.15 : 0.15;

                    const pointData = {
                        // These x,y are placeholder values - not used for imported points during render
                        x: point.gridCol,
                        y: point.gridRow,
                        // Mark as imported with direct cell positions
                        isImported: true,
                        cellRow: point.gridRow,      // 0-indexed row in grid
                        cellCol: point.gridCol,      // 0-indexed column in grid
                        cellKey: `${point.gridRow},${point.gridCol}`, // Ensure unique ID for removal/editing
                        xStagger: xStagger,          // Small offset for stagger pattern
                        importedBoxNum: point.boxNum,
                        importedUniverseNum: point.universeNum
                    };
                    pointCloudData.push(pointData);
                });

                // Set bounds based on actual point positions for compatibility
                // but these won't be used for imported point rendering
                pointCloudBounds = {
                    minX: 0,
                    maxX: totalCols,
                    minY: 0,
                    maxY: totalRows
                };

                console.log('Import - points stored with direct cell positions, bounds:', pointCloudBounds);

                // Detect pitch from imported points
                const uniqueY = [...new Set(pointCloudData.map(p => p.y))].sort((a, b) => a - b);
                let minYDiff = Infinity;
                for (let i = 1; i < uniqueY.length; i++) {
                    const diff = uniqueY[i] - uniqueY[i - 1];
                    if (diff > 0.001) {
                        minYDiff = Math.min(minYDiff, diff);
                    }
                }
                pointCloudPitch.y = minYDiff;

                const uniqueX = [...new Set(pointCloudData.map(p => p.x))].sort((a, b) => a - b);
                let minXDiff = Infinity;
                for (let i = 1; i < uniqueX.length; i++) {
                    const diff = uniqueX[i] - uniqueX[i - 1];
                    if (diff > 0.001) {
                        minXDiff = Math.min(minXDiff, diff);
                    }
                }
                pointCloudPitch.x = minXDiff;

                pointCloudLoaded = true;

                // Set point scale to 1 since imported points are in cell/grid coordinates
                document.getElementById('pointScale').value = 1.0;
                document.getElementById('pointScaleValue').textContent = '1.0x';

                // Don't reset scale/offset - imported points use direct cell positions
                // so they render correctly regardless of scale/offset settings
                // This keeps scale/offset available for any remaining CSV points

                // Calculate cable groups (will respect the imported cellToBoxNumber assignments)
                calculateCableGroups();

                // Log green box counts after import for debugging
                const boxCountsByUniverse = new Map();
                cableGroups.forEach(g => {
                    const count = boxCountsByUniverse.get(g.universeNum) || 0;
                    boxCountsByUniverse.set(g.universeNum, count + 1);
                });
                console.log('IMPORT - Green boxes per universe:', Object.fromEntries(boxCountsByUniverse));
                console.log('IMPORT - Total cableGroups:', cableGroups.length);
                console.log('IMPORT - customBoxPositions count:', customBoxPositions.size);
                // Debug: check if cable group keys match customBoxPositions keys
                cableGroups.forEach(group => {
                    const groupKey = `${group.universeNum}-${group.groupInUniverse}`;
                    const hasCustomPos = customBoxPositions.has(groupKey);
                    console.log(`  Cable group ${groupKey}: hasCustomPos=${hasCustomPos}, points=${group.points.length}`);
                });
                const pointsWithImportedBox = pointCloudData.filter(p => p.importedBoxNum !== undefined && p.importedBoxNum !== null).length;
                console.log('Imported', pointCloudData.length, 'points,', pointsWithImportedBox, 'have imported B numbers');

                // Debug: count cells with B numbers vs cells with dots
                const cellsWithDots = mapData.points.length;
                const cellsWithBNumbers = mapData.cellBoxAssignments ? mapData.cellBoxAssignments.size : 0;
                console.log('IMPORT DEBUG - Cells with dots (‚óè):', cellsWithDots, '| Cells with B numbers:', cellsWithBNumbers);
                if (cellsWithBNumbers > cellsWithDots) {
                    console.warn('WARNING: Some cells have B numbers but no dots - they won\'t have connection lines!');
                }

                // Debug U1 specifically - show direct cell positions from imported points
                const u1Group = cableGroups.find(g => g.universeNum === 1);
                if (u1Group) {
                    // For imported points, just show their direct cellRow/cellCol
                    const u1CellPositions = u1Group.points.map(p => ({
                        cellRow: p.cellRow,
                        cellCol: p.cellCol,
                        isImported: p.isImported
                    }));
                    console.log('IMPORT - U1 group:', {
                        boxNum: u1Group.groupInUniverse,
                        numPoints: u1Group.points.length,
                        center: u1Group.center
                    });
                    // Log all U1 cell positions for direct comparison with EXPORT
                    console.log('IMPORT - U1 cell positions (direct from import):', u1CellPositions);
                }
                // Also log U1 points from pointCloudData
                const u1Points = pointCloudData.filter(p => p.importedUniverseNum === 1 && p.importedBoxNum === 1);
                console.log('IMPORT - U1-B1 points from pointCloudData:', u1Points.length, 'points');
                if (u1Points.length > 0) {
                    console.log('IMPORT - U1-B1 cell positions:', u1Points.map(p => ({ cellRow: p.cellRow, cellCol: p.cellCol })));
                }
            } else {
                pointCloudLoaded = false;
                pointCloudData = [];
                console.log('No points found in imported map');
            }

            // Update preview
            updatePreview();
            saveSettings();
        }

        // Parse exported map structure from Excel file
        function parseExportedMap(worksheet) {
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            console.log('Parsing exported map, range:', range);

            // Count columns (C1, C2, C3...)
            const totalCols = range.e.c; // 0-based, so actual count is this value

            // Count rows (R1, R2, R3...)
            const totalRows = range.e.r; // 0-based, so actual count is this value

            console.log('Grid dimensions:', totalCols, 'cols x', totalRows, 'rows');

            // Map to store universe info: universeNum -> {cells: [{row, col, hasPoint, pointLeft}], minRow, maxRow, minCol, maxCol}
            const universeMap = new Map();
            const customCellData = new Map(); // key: "row,col", value: {index, universe, box, note}
            const boxCells = new Map(); // key: "universeNum-boxNum", value: {row, col} - cells with "Box-N" text
            const cellBoxAssignments = new Map(); // key: "row,col", value: boxNum - B number assignments

            // Parse all data cells (skip header row and column)
            for (let R = 1; R <= range.e.r; R++) {
                for (let C = 1; C <= range.e.c; C++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                    const cell = worksheet[cellAddress];

                    if (cell && cell.v) {
                        const cellText = String(cell.v);
                        const lines = cellText.split('\n');

                        // Filter out Box marker lines so they don't get parsed as cell content (index/notes)
                        // This prevents "Box-U#-N" text from persisting in the cell data when a box is moved
                        const cleanLines = lines.filter(l => !l.match(/^Box-(U\d+-)?\d+$/));
                        const cleanCellText = cleanLines.join('\n');

                        // Parse custom cell data using the cleaned text
                        const parsedData = parseCellContent(cleanCellText);
                        if (parsedData.index || parsedData.universe || parsedData.box || parsedData.note) {
                            const cellKey = `${R - 1},${C - 1}`; // Convert to 0-based
                            customCellData.set(cellKey, parsedData);
                        }

                        // Look for universe number (e.g., "U3" or "U3-B2")
                        let universeNum = null;
                        // NEW: B (with or without number) is the MASTER switch for having a point
                        // We check the clean text (excluding Box-N markers)
                        let hasPoint = cleanCellText.match(/\bB\d*\b/i) !== null;

                        // Dot marker is ONLY for stagger
                        let hasDotMarker = cellText.includes('‚óè') || cellText.includes('‚Ä¢') || cellText.includes('¬∑');
                        let pointLeft = false;
                        let boxNum = null;       // B# assignment for this cell
                        let boxCellNum = null;   // Box-N marker (green box position)
                        let isBoxCell = false;


                        for (const line of lines) {
                            let currentLineIsBox = false;

                            // Check for "Box-U#-N" text first (new detailed format)
                            // Format: Box-U<UniverseNum>-<GroupNum>
                            const detailedBoxMatch = line.match(/^Box-U(\d+)-(\d+)$/);
                            if (detailedBoxMatch) {
                                isBoxCell = true;
                                currentLineIsBox = true;
                                const uNum = parseInt(detailedBoxMatch[1]);
                                boxCellNum = parseInt(detailedBoxMatch[2]);

                                // For detailed boxes, we explicitly know the universe
                                // We can store this directly or use it to override the inferred universe
                                // However, the current logic relies on universeNum being set below by the cell position's U marker
                                // But since this is a box position, we should trust the explicit marker for the box itself

                                // We'll store a special "explicit universe" for this box
                                // This solves the bug where dragging a U1 box into U2 grid space made it become a U2 box
                                // We handle this when storing the boxCells map entry below
                            }
                            // Check for legacy "Box-N" text (backward compatibility)
                            else {
                                const boxCellMatch = line.match(/^Box-(\d+)$/);
                                if (boxCellMatch) {
                                    isBoxCell = true;
                                    currentLineIsBox = true;
                                    boxCellNum = parseInt(boxCellMatch[1]);
                                }
                            }

                            // Check for universe number
                            const universeMatch = line.match(/U(\d+)/);
                            if (universeMatch) {
                                universeNum = parseInt(universeMatch[1]);
                            }

                            // Check for B number assignment (e.g., "B5" standalone or "U1-B5" combined)
                            // Don't match "Box-N" lines (already handled above)
                            // Only set boxNum if not already found (prevents notes from overwriting)
                            if (!currentLineIsBox && boxNum === null) {
                                const bMatch = line.match(/B(\d+)/);
                                if (bMatch) {
                                    boxNum = parseInt(bMatch[1]);
                                }
                            }
                        }

                        // Store box cell position (where green box should be placed)
                        if (isBoxCell && boxCellNum !== null) {
                            // If we have an explicit universe from the detailed Box-U#-N format, use it
                            // Otherwise fallback to the universe inferred from the cell's "U#" text or position
                            let finalUniverseNum = universeNum;

                            const detailedBoxMatch = lines.find(l => l.match(/^Box-U(\d+)-(\d+)$/));
                            if (detailedBoxMatch) {
                                const match = detailedBoxMatch.match(/^Box-U(\d+)-(\d+)$/);
                                finalUniverseNum = parseInt(match[1]);
                            }

                            if (finalUniverseNum !== null) {
                                const boxKey = `${finalUniverseNum}-${boxCellNum}`;
                                boxCells.set(boxKey, { row: R - 1, col: C - 1 }); // 0-based
                            }
                        }

                        // Store cell-to-box assignment
                        if (boxNum !== null && universeNum !== null) {
                            const cellKey = `${R - 1},${C - 1}`;
                            cellBoxAssignments.set(cellKey, boxNum);
                        }

                        // Check if point is on left or right (handle different bullet chars)
                        // This only sets pointLeft if a dot is actually present
                        if (hasDotMarker && lines.length > 0) {
                            const firstLine = lines[0].trim();
                            pointLeft = firstLine.startsWith('‚óè') || firstLine.startsWith('‚Ä¢') || firstLine.startsWith('¬∑');
                        } else if (hasPoint) {
                            // Fallback if B exists but no dot - use default staggered look (parity-based or just left)
                            pointLeft = true;
                        }

                        if (universeNum) {
                            if (!universeMap.has(universeNum)) {
                                universeMap.set(universeNum, {
                                    cells: [],
                                    minRow: R,
                                    maxRow: R,
                                    minCol: C,
                                    maxCol: C
                                });
                            }

                            const uniData = universeMap.get(universeNum);
                            uniData.cells.push({ row: R, col: C, hasPoint, pointLeft, boxNum });
                            uniData.minRow = Math.min(uniData.minRow, R);
                            uniData.maxRow = Math.max(uniData.maxRow, R);
                            uniData.minCol = Math.min(uniData.minCol, C);
                            uniData.maxCol = Math.max(uniData.maxCol, C);
                        }
                    }
                }
            }

            console.log('Found', boxCells.size, 'box positions and', cellBoxAssignments.size, 'cell-to-box assignments');

            console.log('Found', universeMap.size, 'universes');

            // Determine universe grid layout
            // Find max universe number to determine total count
            const maxUniverseNum = Math.max(...Array.from(universeMap.keys()));

            // Calculate grid dimensions for universes
            // We need to determine universesH and universesV from the layout
            // Strategy: find the universe positions and infer the grid

            // Get position of each universe (top-left corner)
            const universePositions = new Map();
            universeMap.forEach((data, num) => {
                universePositions.set(num, { row: data.minRow, col: data.minCol });
            });

            // Find unique row and column positions
            const uniqueRows = [...new Set(Array.from(universePositions.values()).map(p => p.row))].sort((a, b) => a - b);
            const uniqueCols = [...new Set(Array.from(universePositions.values()).map(p => p.col))].sort((a, b) => a - b);

            const universesV = uniqueRows.length;
            const universesH = uniqueCols.length;

            console.log('Universe grid:', universesH, 'x', universesV);

            // Build universe grid structure
            const universes = [];
            for (let uRow = 0; uRow < universesV; uRow++) {
                const rowArray = [];
                for (let uCol = 0; uCol < universesH; uCol++) {
                    // Find which universe is at this position
                    const targetRow = uniqueRows[uRow];
                    const targetCol = uniqueCols[uCol];

                    let foundUniverse = null;
                    universeMap.forEach((data, num) => {
                        if (data.minRow === targetRow && data.minCol === targetCol) {
                            foundUniverse = { num, data };
                        }
                    });

                    if (foundUniverse) {
                        const cols = foundUniverse.data.maxCol - foundUniverse.data.minCol + 1;
                        const rows = foundUniverse.data.maxRow - foundUniverse.data.minRow + 1;
                        rowArray.push({ cols, rows });
                    } else {
                        // Shouldn't happen, but handle gracefully
                        rowArray.push({ cols: 20, rows: 10 });
                    }
                }
                universes.push(rowArray);
            }

            // Extract point locations
            const points = [];
            universeMap.forEach((data, num) => {
                data.cells.forEach(cell => {
                    if (cell.hasPoint) {
                        // Convert cell position (1-based in Excel) to 0-based grid position
                        points.push({
                            gridRow: cell.row - 1,  // -1 to account for header row
                            gridCol: cell.col - 1,  // -1 to account for header column
                            leftStagger: cell.pointLeft,
                            boxNum: cell.boxNum,    // Include B number for direct assignment
                            universeNum: num        // Include universe for box key creation
                        });
                    }
                });
            });

            const pointsWithBoxNum = points.filter(p => p.boxNum !== null && p.boxNum !== undefined).length;
            console.log('Extracted', points.length, 'points,', pointsWithBoxNum, 'have B numbers');

            // Debug U1 points - show original Excel positions
            const u1ParsedPoints = points.filter(p => p.universeNum === 1);
            if (u1ParsedPoints.length > 0) {
                console.log('PARSE - U1 points from Excel:', u1ParsedPoints.length, 'points');
                console.log('PARSE - U1 grid positions (gridRow, gridCol):', u1ParsedPoints.map(p => ({
                    gridRow: p.gridRow,
                    gridCol: p.gridCol,
                    boxNum: p.boxNum,
                    leftStagger: p.leftStagger
                })));
                console.log('PARSE - totalRows:', totalRows, 'totalCols:', totalCols);
            }

            return {
                universesH,
                universesV,
                universes,
                points,
                totalCols,
                totalRows,
                customCellData,
                boxCells,           // Map of "universeNum-boxNum" -> {row, col} for green box positions
                cellBoxAssignments  // Map of "row,col" -> boxNum for cell-to-box assignments
            };
        }

        // Parse CSV text into point cloud data
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');

            // Skip header line
            pointCloudData = [];
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length >= 3) {
                    const x = parseFloat(parts[1]); // px column
                    const y = parseFloat(parts[2]); // py column
                    if (!isNaN(x) && !isNaN(y)) {
                        pointCloudData.push({ x, y });
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // Detect pitch (fixed spacing) in Y direction
            // Find unique Y values and calculate minimum non-zero difference
            const uniqueY = [...new Set(pointCloudData.map(p => p.y))].sort((a, b) => a - b);
            let minYDiff = Infinity;
            for (let i = 1; i < uniqueY.length; i++) {
                const diff = uniqueY[i] - uniqueY[i - 1];
                if (diff > 0.001) { // Ignore tiny differences (floating point errors)
                    minYDiff = Math.min(minYDiff, diff);
                }
            }
            pointCloudPitch.y = minYDiff;

            // Same for X direction
            const uniqueX = [...new Set(pointCloudData.map(p => p.x))].sort((a, b) => a - b);
            let minXDiff = Infinity;
            for (let i = 1; i < uniqueX.length; i++) {
                const diff = uniqueX[i] - uniqueX[i - 1];
                if (diff > 0.001) {
                    minXDiff = Math.min(minXDiff, diff);
                }
            }
            pointCloudPitch.x = minXDiff;

            // Store bounds for normalization
            pointCloudBounds = { minX, maxX, minY, maxY };
            pointCloudLoaded = true;

            console.log('Point cloud loaded:', pointCloudData.length, 'points');
            console.log('X range:', minX, 'to', maxX, '(width:', maxX - minX, ')');
            console.log('Y range:', minY, 'to', maxY, '(height:', maxY - minY, ')');
            console.log('Detected pitch - X:', pointCloudPitch.x.toFixed(3), 'Y:', pointCloudPitch.y.toFixed(3));

            // Calculate ideal point scale to match cell size
            // If pitch * baseCellSize * pointScale = baseCellSize, then pointScale = 1 / pitch
            const baseCellSize = 60;
            const idealScale = 1 / pointCloudPitch.y; // Use Y pitch as reference
            console.log('Ideal point scale to match cells:', idealScale.toFixed(3));

            // Auto-set the point scale if not already manually adjusted
            const currentScale = parseFloat(document.getElementById('pointScale').value);
            if (Math.abs(currentScale - 1.0) < 0.01) { // Only auto-adjust if still at default
                document.getElementById('pointScale').value = idealScale.toFixed(3);
                document.getElementById('pointScaleValue').textContent = idealScale.toFixed(2) + 'x';
                console.log('Auto-adjusted point scale to:', idealScale.toFixed(3));
            }

            // Calculate cable groups
            console.log('CSV loaded, offset values before calculateCableGroups:', {
                offsetX: document.getElementById('pointOffsetX')?.value,
                offsetY: document.getElementById('pointOffsetY')?.value
            });
            calculateCableGroups();

            // Log green box counts after CSV load for debugging
            const boxCountsByUniverse = new Map();
            cableGroups.forEach(g => {
                const count = boxCountsByUniverse.get(g.universeNum) || 0;
                boxCountsByUniverse.set(g.universeNum, count + 1);
            });
            console.log('CSV LOAD - Green boxes per universe:', Object.fromEntries(boxCountsByUniverse));
            console.log('CSV LOAD - Total cableGroups:', cableGroups.length);
        }

        // Calculate cable groups - group by universe, 20 points per group, starting from top-right
        function calculateCableGroups() {
            cableGroups = [];
            // Preserve manual B number assignments
            const manualAssignments = new Map(cellToBoxNumber);
            cellToBoxNumber.clear(); // Clear for recalculation
            const groupSize = 20;

            // Get point transformation settings - protect against null bounds on empty maps
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
            const baseCellSize = 60;

            const csvWidth = pointCloudBounds ? (pointCloudBounds.maxX - pointCloudBounds.minX) : 0;
            const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;

            // Assign each point to a universe based on its cell position (variable grid)
            const pointsByUniverse = new Map();

            pointCloudData.forEach((point, idx) => {
                // For imported points with universe assignment, use it directly
                // This avoids coordinate system mismatches between original CSV and imported cell-based coords
                if (point.importedUniverseNum !== undefined && point.importedUniverseNum !== null) {
                    const universeNum = point.importedUniverseNum;
                    if (!pointsByUniverse.has(universeNum)) {
                        pointsByUniverse.set(universeNum, []);
                    }
                    // For imported points, use the stored cell positions
                    pointsByUniverse.get(universeNum).push({
                        point: point,
                        cellRow: point.cellRow,  // Use actual cell position for B number assignment
                        cellCol: point.cellCol,
                        originalIndex: idx,
                        isImported: true
                    });
                    return; // Skip normal calculation for imported points
                }

                // For non-imported points, calculate cell position from coordinates
                if (!pointCloudBounds) return;
                const relativeX = point.x - pointCloudBounds.minX;
                const relativeY = point.y - pointCloudBounds.minY;

                const gridPixelX = relativeX * baseCellSize * pointScale;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                // Convert to cell indices
                const cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                const cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);

                // Calculate universe from cell position using variable grid
                let universeCol = -1;
                let universeRow = -1;

                // Find which universe this cell belongs to
                for (let uRow = 0; uRow < universeGrid.universesV && universeRow < 0; uRow++) {
                    for (let uCol = 0; uCol < universeGrid.universesH && universeCol < 0; uCol++) {
                        let currentX = 0;
                        for (let c = 0; c < uCol; c++) {
                            currentX += getUniverseCols(uRow, c);
                        }

                        let currentY = 0;
                        for (let r = 0; r < uRow; r++) {
                            currentY += getUniverseRows(r, uCol);
                        }

                        const colsInUniverse = getUniverseCols(uRow, uCol);
                        const rowsInUniverse = getUniverseRows(uRow, uCol);

                        if (cellCol >= currentX && cellCol < currentX + colsInUniverse &&
                            cellRow >= currentY && cellRow < currentY + rowsInUniverse) {
                            universeCol = uCol;
                            universeRow = uRow;
                            break;
                        }
                    }
                }

                if (universeCol >= 0 && universeRow >= 0) {
                    const universeNum = (universeRow * universeGrid.universesH) + universeCol + 1;

                    if (!pointsByUniverse.has(universeNum)) {
                        pointsByUniverse.set(universeNum, []);
                    }

                    pointsByUniverse.get(universeNum).push({
                        point: point,
                        cellRow: cellRow,
                        cellCol: cellCol,
                        originalIndex: idx,
                        isImported: false
                    });
                }
            });

            // Count total points assigned
            let totalAssignedPoints = 0;
            pointsByUniverse.forEach(points => {
                totalAssignedPoints += points.length;
            });



            // For each universe, group points by B number (manual or automatic)
            pointsByUniverse.forEach((universePoints, universeNum) => {
                // First, check for manual B number assignments
                const pointsWithManualBox = [];
                const pointsWithoutBox = [];
                const pointsExplicitlyNoBox = []; // Points with explicitly empty B field

                universePoints.forEach(pointData => {
                    const key = `${pointData.cellRow},${pointData.cellCol}`;
                    const manualBoxNum = manualAssignments.get(key);
                    const customData = cellCustomData.get(key);

                    // Check for imported box number directly on the point (from XLSX import)
                    // This takes priority because it's a direct assignment that doesn't depend on cell position calculation
                    // For CSV-loaded points, this will be undefined (safe to access)
                    const importedBoxNum = pointData.point ? pointData.point.importedBoxNum : undefined;

                    // Priority: 1) manual cell-based assignment (USER EDIT), 2) imported box num from point, 3) auto-assign
                    if (manualBoxNum !== undefined) {
                        pointsWithManualBox.push({ ...pointData, boxNum: manualBoxNum });
                        // Restore the manual assignment (redundant but safe)
                        cellToBoxNumber.set(key, manualBoxNum);
                    } else if (importedBoxNum !== undefined && importedBoxNum !== null) {
                        pointsWithManualBox.push({ ...pointData, boxNum: importedBoxNum });
                        // Store the assignment for this calculated cell position
                        cellToBoxNumber.set(key, importedBoxNum);
                    } else if (customData && customData.box === '') {
                        // Explicitly no box (and no manual assignment) - don't assign to any group
                        pointsExplicitlyNoBox.push(pointData);
                    } else {
                        pointsWithoutBox.push(pointData);
                    }
                });

                // Group points with manual assignments by their box number
                const manualGroups = new Map();
                pointsWithManualBox.forEach(pointData => {
                    if (!manualGroups.has(pointData.boxNum)) {
                        manualGroups.set(pointData.boxNum, []);
                    }
                    manualGroups.get(pointData.boxNum).push(pointData);
                });

                // For points without manual assignments, sort and auto-group
                pointsWithoutBox.sort((a, b) => {
                    if (a.cellRow !== b.cellRow) {
                        return a.cellRow - b.cellRow; // Top rows first
                    }
                    return b.cellCol - a.cellCol; // Right columns first within same row
                });

                // Auto-assign box numbers to unassigned points
                // NEW: SEED & FILL STRATEGY
                // 1. First, any manual assignments in this universe "seed" a cable group ID.
                // 2. We then try to fill these "seeded" groups to 'groupSize' (20) with unassigned points.
                // 3. Only after seeded groups are full do we create brand new IDs.

                let seededGroupIDs = Array.from(manualGroups.keys()).sort((a, b) => a - b);
                let unassignedPoints = [...pointsWithoutBox];

                // Fill seeded groups
                seededGroupIDs.forEach(boxNum => {
                    let group = manualGroups.get(boxNum);
                    let spaceLeft = groupSize - group.length;
                    if (spaceLeft > 0 && unassignedPoints.length > 0) {
                        let toAdd = unassignedPoints.splice(0, spaceLeft);
                        toAdd.forEach(p => {
                            const key = `${p.cellRow},${p.cellCol}`;
                            cellToBoxNumber.set(key, boxNum);
                            group.push(p);
                        });
                    }
                });

                // Create new groups for leftover points
                let nextBoxNum = 1;
                while (unassignedPoints.length > 0) {
                    // Find next available boxNum globally (not used by ANY manual group in this universe)
                    while (manualGroups.has(nextBoxNum)) {
                        nextBoxNum++;
                    }

                    const groupPointsData = unassignedPoints.splice(0, groupSize);
                    const boxNum = nextBoxNum;

                    manualGroups.set(boxNum, groupPointsData);
                    groupPointsData.forEach(p => {
                        const key = `${p.cellRow},${p.cellCol}`;
                        cellToBoxNumber.set(key, boxNum);
                    });
                    nextBoxNum++;
                }

                // Create cable groups from all groups (manual and auto)
                manualGroups.forEach((groupPointsData, boxNum) => {
                    const groupPoints = groupPointsData.map(p => p.point);

                    // Calculate center point (green dot position)
                    // For imported points, use cell positions; for CSV points, use x,y coordinates
                    let centerX, centerY;
                    const hasImportedPoints = groupPoints.some(p => p.isImported);

                    if (hasImportedPoints) {
                        // Calculate center from cell positions
                        let sumCol = 0, sumRow = 0;
                        let count = 0;
                        groupPoints.forEach(point => {
                            // Support both imported points (cellCol) and mapped CSV points if available
                            const r = point.cellRow !== undefined ? point.cellRow : (point.isImported ? undefined : -1);
                            const c = point.cellCol !== undefined ? point.cellCol : (point.isImported ? undefined : -1);

                            if (r !== undefined && c !== undefined && r !== -1) {
                                sumCol += c + 0.5;
                                sumRow += r + 0.5;
                                count++;
                            }
                        });

                        if (count > 0) {
                            centerX = sumCol / count;
                            centerY = sumRow / count;
                        } else {
                            // Fallback if somehow no points had cell coordinates
                            centerX = 0; centerY = 0;
                        }
                    } else {
                        // CSV points: use original x,y coordinates
                        let sumX = 0, sumY = 0;
                        groupPoints.forEach(point => {
                            sumX += point.x;
                            sumY += point.y;
                        });
                        centerX = sumX / groupPoints.length;
                        centerY = sumY / groupPoints.length;
                    }

                    cableGroups.push({
                        points: groupPoints,
                        center: { x: centerX, y: centerY, isImported: hasImportedPoints },
                        universeNum: universeNum,
                        groupInUniverse: boxNum
                    });
                });
            });

        }

        // Load point cloud data from CSV file
        async function loadPointCloud() {
            try {
                const response = await fetch('layout.csv');
                const csvText = await response.text();
                parseCSV(csvText);
                updatePreview(); // Redraw with points
            } catch (error) {
                console.error('Failed to load point cloud:', error);
                pointCloudLoaded = false;
            }
        }

        // Generate universe colors
        function generateUniverseColors(totalUniverses) {
            const baseColors = [
                'FF6B6B', '4ECDC4', 'FFE66D', '95E1D3', 'FF8B94', 'A8E6CF',
                'FFD93D', '6BCF7F', 'FFA07A', '87CEEB', 'DDA15E', 'B4A7D6',
                'FFC0CB', '98D8C8', 'FFD700', '9370DB', 'FFA500', '20B2AA',
                'FF69B4', '7FFFD4', 'FFDAB9', '8FBC8F', 'FFC1CC', 'AFEEEE',
                'FFB6C1', '00CED1', 'FFA07A', '9ACD32', 'FF7F50', '48D1CC',
                'FFD700', '9932CC', 'FF8C00', '00FA9A', 'DA70D6', '32CD32',
            ];

            const colors = {};
            for (let i = 0; i < totalUniverses; i++) {
                colors[i + 1] = baseColors[i % baseColors.length];
            }
            return colors;
        }

        // Draw point cloud overlay
        function drawPointCloud(ctx, gridOffsetX, gridOffsetY, gridScale, pointScale, pointSize, pointOffsetX, pointOffsetY) {
            // Base cell size from the pre-rendered grid
            const baseCellSize = 60;

            // Calculate CSV data range - protect against null bounds
            const csvWidth = pointCloudBounds ? (pointCloudBounds.maxX - pointCloudBounds.minX) : 0;
            const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;


            ctx.save();

            let drawnCount = 0;
            let visibleCount = 0;

            // Draw each point
            pointCloudData.forEach((point, idx) => {
                let gridPixelXWithOffset, gridPixelYFlippedWithOffset;
                let cellCol, cellRow;

                if (point.isImported) {
                    // Imported points: place directly at cell positions (no CSV transformation)
                    // Cell center is at (col + 0.5) * baseCellSize, (row + 0.5) * baseCellSize
                    cellCol = point.cellCol;
                    cellRow = point.cellRow;
                    const xStagger = point.xStagger || 0;
                    gridPixelXWithOffset = (cellCol + 0.5 + xStagger) * baseCellSize;
                    gridPixelYFlippedWithOffset = (cellRow + 0.5) * baseCellSize;
                } else {
                    // CSV points: use original transformation with scale and offset
                    const relativeX = point.x - pointCloudBounds.minX;
                    const relativeY = point.y - pointCloudBounds.minY;

                    // Convert to "grid pixel space" (as if in the high-res rendered image)
                    // Scale to match cell size, apply point scale adjustment
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelY = relativeY * baseCellSize * pointScale;

                    // Flip Y coordinate
                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                    // Apply offsets in grid space (before scale so they zoom with the map)
                    gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                    // Convert to cell indices
                    cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                    cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);
                }

                const cellKey = `${cellRow},${cellCol}`;

                // Check if this cell has explicitly empty B - if so, skip drawing the point
                const customData = cellCustomData.get(cellKey);
                const hasBoxNumber = cellToBoxNumber.has(cellKey);


                // Don't draw if B is explicitly empty (in custom data) AND there's no box number assigned
                // If there's a box number, always draw (even if customData.box was previously empty)
                if (customData && customData.box === '' && !hasBoxNumber) {
                    // Cell has explicitly empty B and no box number - don't draw the point
                    return;
                }

                // If there's a box number, the point should be drawn (will be connected to green dot)

                // Apply grid's transformation (same as the spread-map image)
                // This makes points zoom/pan with the map
                const px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                const py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);

                // Check if point is visible on canvas
                const isVisible = px >= -50 && px <= ctx.canvas.width + 50 &&
                    py >= -50 && py <= ctx.canvas.height + 50;
                if (isVisible) visibleCount++;

                // Draw point as a circle (scale size with grid zoom)
                const scaledPointSize = pointSize * gridScale;
                ctx.beginPath();
                ctx.arc(px, py, scaledPointSize, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = Math.max(1, gridScale * 0.5);
                ctx.stroke();

                drawnCount++;

            });


            // Draw a reference cross at the point cloud origin
            const originX = gridOffsetX + (pointOffsetX * gridScale);
            const originY = gridOffsetY + ((csvHeight * baseCellSize * pointScale + pointOffsetY) * gridScale);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(originX - 30, originY);
            ctx.lineTo(originX + 30, originY);
            ctx.moveTo(originX, originY - 30);
            ctx.lineTo(originX, originY + 30);
            ctx.stroke();

            ctx.restore();
        }

        // Draw cable group lines - lines from each point to the group center
        function drawCableGroups(ctx, gridOffsetX, gridOffsetY, gridScale, pointScale, pointOffsetX, pointOffsetY) {
            const baseCellSize = 60;
            const csvWidth = pointCloudBounds ? (pointCloudBounds.maxX - pointCloudBounds.minX) : 0;
            const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;

            ctx.save();

            // Helper function to convert point coordinates to screen coordinates
            function pointToScreen(point) {
                let gridPixelXWithOffset, gridPixelYFlippedWithOffset;

                if (point.isImported) {
                    // Imported points/centers: place directly at cell positions
                    if (point.cellCol !== undefined && point.cellRow !== undefined) {
                        // Individual point with explicit cell position
                        const xStagger = point.xStagger || 0;
                        gridPixelXWithOffset = (point.cellCol + 0.5 + xStagger) * baseCellSize;
                        gridPixelYFlippedWithOffset = (point.cellRow + 0.5) * baseCellSize;
                    } else {
                        // Center point: x,y are already cell-based coordinates
                        gridPixelXWithOffset = point.x * baseCellSize;
                        gridPixelYFlippedWithOffset = point.y * baseCellSize;
                    }
                } else {
                    // CSV points: use original transformation with scale and offset
                    const relativeX = point.x - pointCloudBounds.minX;
                    const relativeY = point.y - pointCloudBounds.minY;

                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelY = relativeY * baseCellSize * pointScale;

                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                    gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;
                }

                const px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                const py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);

                return { x: px, y: py };
            }

            // Draw each cable group
            cableGroups.forEach((group, groupIndex) => {
                // Check for custom box position
                const boxKey = `${group.universeNum}-${group.groupInUniverse}`;
                let boxScreenX, boxScreenY;

                if (customBoxPositions.has(boxKey)) {
                    // Use custom position (stored in grid pixel space)
                    const customPos = customBoxPositions.get(boxKey);
                    boxScreenX = gridOffsetX + (customPos.x * gridScale);
                    boxScreenY = gridOffsetY + (customPos.y * gridScale);
                } else {
                    // Use calculated center position
                    const centerScreen = pointToScreen(group.center);
                    boxScreenX = centerScreen.x;
                    boxScreenY = centerScreen.y;
                }

                // Draw lines from each point to box position
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; // Black for cables
                ctx.lineWidth = Math.max(1, gridScale * 1.5);

                group.points.forEach(point => {
                    const pointScreen = pointToScreen(point);

                    ctx.beginPath();
                    ctx.moveTo(pointScreen.x, pointScreen.y);
                    ctx.lineTo(boxScreenX, boxScreenY);
                    ctx.stroke();
                });

                // Draw center point marker (green rectangle with black outline)
                const markerWidth = Math.max(30, gridScale * 40);
                const markerHeight = Math.max(16, gridScale * 20);
                const markerX = boxScreenX - markerWidth / 2;
                const markerY = boxScreenY - markerHeight / 2;

                // Store marker bounds for hit detection
                group.markerBounds = {
                    x: markerX,
                    y: markerY,
                    width: markerWidth,
                    height: markerHeight,
                    screenX: boxScreenX,
                    screenY: boxScreenY
                };

                // Green fill
                ctx.fillStyle = 'rgba(34, 197, 94, 0.9)'; // Green
                ctx.fillRect(markerX, markerY, markerWidth, markerHeight);

                // Black outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.lineWidth = Math.max(2, gridScale * 2);
                ctx.strokeRect(markerX, markerY, markerWidth, markerHeight);

                // Draw group number label (white text)
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.font = `bold ${Math.max(10, gridScale * 12)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`U${group.universeNum}-${group.groupInUniverse}`, boxScreenX, boxScreenY);
            });

            ctx.restore();

        }

        // Helper function to find which universe a cell belongs to
        function getCellUniverse(cellCol, cellRow) {
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                    // Calculate X position by summing widths in the SAME ROW
                    let currentX = 0;
                    for (let c = 0; c < uCol; c++) {
                        currentX += getUniverseCols(uRow, c);
                    }

                    // Calculate Y position by summing heights in the SAME COLUMN
                    let currentY = 0;
                    for (let r = 0; r < uRow; r++) {
                        currentY += getUniverseRows(r, uCol);
                    }

                    const colsInUniverse = getUniverseCols(uRow, uCol);
                    const rowsInUniverse = getUniverseRows(uRow, uCol);

                    if (cellCol >= currentX && cellCol < currentX + colsInUniverse &&
                        cellRow >= currentY && cellRow < currentY + rowsInUniverse) {
                        return {
                            uRow: uRow,
                            uCol: uCol,
                            universeNum: (uRow * universeGrid.universesH) + uCol + 1,
                            cellInUniverseCol: cellCol - currentX,
                            cellInUniverseRow: cellRow - currentY
                        };
                    }
                }
            }
            return null; // Cell doesn't belong to any universe
        }

        // Draw dynamic grid directly to canvas (supports variable universe sizes with cut-out corners)
        // Draw row and column headers on all four edges (R1, R2... for rows, C1, C2... for columns)
        function drawRowColHeaders(ctx, offsetX, offsetY, scale, totalCols, totalRows) {
            const baseCellSize = 60;
            const headerSize = 30 * scale; // Size of header cells
            const gridWidth = totalCols * baseCellSize * scale;
            const gridHeight = totalRows * baseCellSize * scale;

            ctx.save();
            ctx.fillStyle = 'rgba(50, 50, 60, 0.9)';

            // Top column headers background
            ctx.fillRect(offsetX, offsetY - headerSize, gridWidth, headerSize);

            // Bottom column headers background
            ctx.fillRect(offsetX, offsetY + gridHeight, gridWidth, headerSize);

            // Left row headers background
            ctx.fillRect(offsetX - headerSize, offsetY, headerSize, gridHeight);

            // Right row headers background
            ctx.fillRect(offsetX + gridWidth, offsetY, headerSize, gridHeight);

            // Corner cells
            ctx.fillRect(offsetX - headerSize, offsetY - headerSize, headerSize, headerSize); // Top-left
            ctx.fillRect(offsetX + gridWidth, offsetY - headerSize, headerSize, headerSize); // Top-right
            ctx.fillRect(offsetX - headerSize, offsetY + gridHeight, headerSize, headerSize); // Bottom-left
            ctx.fillRect(offsetX + gridWidth, offsetY + gridHeight, headerSize, headerSize); // Bottom-right

            // Text style
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(8, 10 * scale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Column headers (C1, C2, etc.) - top and bottom
            for (let col = 0; col < totalCols; col++) {
                const x = offsetX + (col + 0.5) * baseCellSize * scale;
                const colLabel = `C${col + 1}`;
                // Top
                ctx.fillText(colLabel, x, offsetY - headerSize / 2);
                // Bottom
                ctx.fillText(colLabel, x, offsetY + gridHeight + headerSize / 2);
            }

            // Row headers (R1, R2, etc.) - left and right
            for (let row = 0; row < totalRows; row++) {
                const y = offsetY + (row + 0.5) * baseCellSize * scale;
                const rowLabel = `R${row + 1}`;
                // Left
                ctx.fillText(rowLabel, offsetX - headerSize / 2, y);
                // Right
                ctx.fillText(rowLabel, offsetX + gridWidth + headerSize / 2, y);
            }

            // Draw header borders
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;

            // Top column header border
            ctx.strokeRect(offsetX, offsetY - headerSize, gridWidth, headerSize);
            // Bottom column header border
            ctx.strokeRect(offsetX, offsetY + gridHeight, gridWidth, headerSize);
            // Left row header border
            ctx.strokeRect(offsetX - headerSize, offsetY, headerSize, gridHeight);
            // Right row header border
            ctx.strokeRect(offsetX + gridWidth, offsetY, headerSize, gridHeight);

            // Corner borders
            ctx.strokeRect(offsetX - headerSize, offsetY - headerSize, headerSize, headerSize);
            ctx.strokeRect(offsetX + gridWidth, offsetY - headerSize, headerSize, headerSize);
            ctx.strokeRect(offsetX - headerSize, offsetY + gridHeight, headerSize, headerSize);
            ctx.strokeRect(offsetX + gridWidth, offsetY + gridHeight, headerSize, headerSize);

            ctx.restore();
        }

        // Draw crosshair with 50px gap around mouse cursor and labels at 100px
        function drawCrosshair(ctx, mouseX, mouseY, canvasWidth, canvasHeight, cellRow, cellCol) {
            if (mouseX < 0 || mouseY < 0) return;

            const gap = 50; // Gap around mouse cursor
            const labelDistance = 100; // Distance from mouse for labels

            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // 50% transparent black
            ctx.lineWidth = 1;

            // Vertical line (top part)
            ctx.beginPath();
            ctx.moveTo(mouseX, 0);
            ctx.lineTo(mouseX, mouseY - gap);
            ctx.stroke();

            // Vertical line (bottom part)
            ctx.beginPath();
            ctx.moveTo(mouseX, mouseY + gap);
            ctx.lineTo(mouseX, canvasHeight);
            ctx.stroke();

            // Horizontal line (left part)
            ctx.beginPath();
            ctx.moveTo(0, mouseY);
            ctx.lineTo(mouseX - gap, mouseY);
            ctx.stroke();

            // Horizontal line (right part)
            ctx.beginPath();
            ctx.moveTo(mouseX + gap, mouseY);
            ctx.lineTo(canvasWidth, mouseY);
            ctx.stroke();

            // 45¬∞ diagonal line (top-right direction) - going from mouse up and to the right
            ctx.beginPath();
            const diag1StartX = mouseX + gap * Math.cos(Math.PI / 4);
            const diag1StartY = mouseY - gap * Math.sin(Math.PI / 4);
            ctx.moveTo(diag1StartX, diag1StartY);
            // Calculate where line exits canvas (top or right edge)
            const distToTop = mouseY;
            const distToRight = canvasWidth - mouseX;
            if (distToTop < distToRight) {
                // Hits top edge first
                ctx.lineTo(mouseX + distToTop, 0);
            } else {
                // Hits right edge first
                ctx.lineTo(canvasWidth, mouseY - distToRight);
            }
            ctx.stroke();

            // 45¬∞ diagonal line (bottom-left direction) - going from mouse down and to the left
            ctx.beginPath();
            const diag2StartX = mouseX - gap * Math.cos(Math.PI / 4);
            const diag2StartY = mouseY + gap * Math.sin(Math.PI / 4);
            ctx.moveTo(diag2StartX, diag2StartY);
            // Calculate where line exits canvas (bottom or left edge)
            const distToBottom = canvasHeight - mouseY;
            const distToLeft = mouseX;
            if (distToBottom < distToLeft) {
                // Hits bottom edge first
                ctx.lineTo(mouseX - distToBottom, canvasHeight);
            } else {
                // Hits left edge first
                ctx.lineTo(0, mouseY + distToLeft);
            }
            ctx.stroke();

            // Draw row and column labels if we have valid cell coordinates
            if (cellRow !== null && cellCol !== null && cellRow >= 0 && cellCol >= 0) {
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const rowLabel = `R${cellRow + 1}`;
                const colLabel = `C${cellCol + 1}`;

                // Draw label background and text helper
                const drawLabel = (text, x, y) => {
                    const padding = 4;
                    const metrics = ctx.measureText(text);
                    const textWidth = metrics.width;
                    const textHeight = 14;

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x - textWidth / 2 - padding, y - textHeight / 2 - padding, textWidth + padding * 2, textHeight + padding * 2);

                    // Text
                    ctx.fillStyle = '#fff';
                    ctx.fillText(text, x, y);
                };

                // Column label on vertical line (above gap)
                if (mouseY - labelDistance > 0) {
                    drawLabel(colLabel, mouseX, mouseY - labelDistance);
                }

                // Row label on horizontal line (left of gap)
                if (mouseX - labelDistance > 0) {
                    drawLabel(rowLabel, mouseX - labelDistance, mouseY);
                }
            }

            ctx.restore();
        }

        function drawDynamicGrid(ctx, offsetX, offsetY, scale, colors, mapAlpha = 1.0) {
            const baseCellSize = 60;

            // Calculate total grid dimensions
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();

            // Draw cells globally (prevents overlaps, creates cut-out corners)
            for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                    // Find which universe this cell belongs to
                    const cellUniverse = getCellUniverse(cellCol, cellRow);

                    if (!cellUniverse) continue; // Skip cells that don't belong to any universe

                    const universeNum = cellUniverse.universeNum;
                    const hexColor = colors[universeNum] || 'CCCCCC';

                    // Calculate cell position
                    const x = cellCol * baseCellSize;
                    const y = cellRow * baseCellSize;
                    const cellWidth = baseCellSize;
                    const cellHeight = baseCellSize;

                    // Transform to screen coordinates
                    const screenX = offsetX + (x * scale);
                    const screenY = offsetY + (y * scale);
                    const screenWidth = cellWidth * scale;
                    const screenHeight = cellHeight * scale;

                    // Determine if cell has a B-number assigned
                    const cellKey = `${cellRow},${cellCol}`;
                    const customData = cellCustomData.get(cellKey);
                    const boxNum = cellToBoxNumber.get(cellKey);
                    const hasBoxNumber = (customData && customData.box) || boxNum !== undefined;

                    // Cells without B-number are 50% more transparent
                    ctx.globalAlpha = hasBoxNumber ? mapAlpha : mapAlpha * 0.5;

                    // Fill cell with universe color
                    ctx.fillStyle = '#' + hexColor;
                    ctx.fillRect(screenX, screenY, screenWidth, screenHeight);

                    // Draw cell border
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = Math.max(0.5, scale * 0.5);
                    ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);

                    // Draw cell ID in top-left corner (for debugging)
                    if (scale > 0.2) {
                        ctx.fillStyle = 'rgba(0, 0, 128, 0.7)';
                        ctx.font = `${Math.max(5, scale * 6)}px monospace`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`${cellRow + 1},${cellCol + 1}`, screenX + 2, screenY + 2);
                    }

                    // Draw cell text only if enabled
                    if (universeGrid.showCellText && scale > 0.3) {
                        // Note: cellKey, customData, boxNum already defined above for alpha calculation

                        if (customData) {
                            // Draw custom formatted cell content (without & prefix)
                            // Use same vertical distribution as default format for consistency
                            ctx.fillStyle = '#000';

                            // 1. Draw Index (Top)
                            if (customData.index) {
                                ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'top';
                                ctx.fillText(customData.index, screenX + screenWidth / 2, screenY + 5 * scale);
                            }

                            // 2. Draw Universe (Middle)
                            if (customData.universe) {
                                ctx.font = `bold ${Math.max(7, scale * 8)}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`U${customData.universe}`, screenX + screenWidth / 2, screenY + screenHeight / 2);
                            }

                            // 3. Draw Box (Bottom)
                            let bLabel = '';
                            if (customData.box) {
                                bLabel = `B${customData.box}`;
                            } else if (boxNum !== undefined) {
                                bLabel = `B${boxNum}`;
                            } else {
                                // Only show 'B' if this cell actually has a point
                                // Check if any point in pointCloudData maps to this cell
                                const point = pointCloudData.find(p => p.cellKey === cellKey);
                                if (point) {
                                    bLabel = 'B';
                                }
                            }

                            if (bLabel) {
                                ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';
                                ctx.fillText(bLabel, screenX + screenWidth / 2, screenY + screenHeight - 5 * scale);
                            }

                            // 4. Draw Notes (accumulate below Box if room, or squeeze?)
                            // NOTES are problematic with Top/Middle/Bottom alignment.
                            // If notes exist, the default "Middle" might overlap.
                            // However, the user request is "filling the cell vertical axis the same way".
                            // So we should prioritize the Index/U/B positions.
                            // We'll put notes below the box for now or skip them if they don't fit?
                            // Actually, notes were drawn "stacked" before.
                            // If we use T/M/B, where do notes go?
                            // Default format DOES NOT support notes.
                            // So if there are notes, maybe we should stick to stacked?
                            // OR, put notes slightly above bottom?
                            // Let's assume most cells don't have long notes, and just put them below Middle or above Bottom?

                            // Re-evaluating: The user specifically complained about "space between lines changing".
                            // This implies they WANT the T/M/B "stretched" look.
                            // I will place notes below the B label if possible, or just ignore for main alignment.
                            // Let's place notes strictly at the bottom-most edge or overlapping?
                            // Actually, let's keep it simple: Index Top, Universe Middle, Box Bottom.
                            // Notes: if present, maybe draw smaller below Universe?
                            if (customData.note) {
                                ctx.font = `${Math.max(6, scale * 7)}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'top';
                                ctx.fillText(customData.note, screenX + screenWidth / 2, screenY + screenHeight / 2 + 8 * scale);
                            }
                        } else {
                            // Default format
                            ctx.fillStyle = '#000';
                            ctx.font = `${Math.max(8, scale * 9)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'top';
                            ctx.fillText(`${cellUniverse.cellInUniverseCol + 1}`, screenX + screenWidth / 2, screenY + 5 * scale);

                            ctx.font = `bold ${Math.max(8, scale * 9)}px Arial`;
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`U${universeNum}`, screenX + screenWidth / 2, screenY + screenHeight / 2);

                            ctx.font = `${Math.max(7, scale * 8)}px Arial`;
                            ctx.textBaseline = 'bottom';
                            const bLabel = boxNum !== undefined ? `B${boxNum}` : 'B';
                            ctx.fillText(bLabel, screenX + screenWidth / 2, screenY + screenHeight - 5 * scale);
                        }
                    }
                }
            }

            // Draw universe boundaries
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(2, scale * 3);

            // Draw boundaries between different universes
            for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                    const cellUniverse = getCellUniverse(cellCol, cellRow);
                    if (!cellUniverse) continue;

                    const x = cellCol * baseCellSize;
                    const y = cellRow * baseCellSize;

                    // Check right edge
                    const rightNeighbor = getCellUniverse(cellCol + 1, cellRow);
                    if (!rightNeighbor || rightNeighbor.universeNum !== cellUniverse.universeNum) {
                        const rightX = offsetX + ((x + baseCellSize) * scale);
                        const topY = offsetY + (y * scale);
                        const bottomY = offsetY + ((y + baseCellSize) * scale);
                        ctx.beginPath();
                        ctx.moveTo(rightX, topY);
                        ctx.lineTo(rightX, bottomY);
                        ctx.stroke();
                    }

                    // Check bottom edge
                    const bottomNeighbor = getCellUniverse(cellCol, cellRow + 1);
                    if (!bottomNeighbor || bottomNeighbor.universeNum !== cellUniverse.universeNum) {
                        const leftX = offsetX + (x * scale);
                        const rightX = offsetX + ((x + baseCellSize) * scale);
                        const bottomY = offsetY + ((y + baseCellSize) * scale);
                        ctx.beginPath();
                        ctx.moveTo(leftX, bottomY);
                        ctx.lineTo(rightX, bottomY);
                        ctx.stroke();
                    }
                }
            }

            // Draw large universe labels if text is enabled
            if (universeGrid.showCellText && scale > 0.5) {
                for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                    for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                        // Calculate X position by summing widths in the SAME ROW
                        let currentX = 0;
                        for (let c = 0; c < uCol; c++) {
                            currentX += getUniverseCols(uRow, c);
                        }

                        // Calculate Y position by summing heights in the SAME COLUMN
                        let currentY = 0;
                        for (let r = 0; r < uRow; r++) {
                            currentY += getUniverseRows(r, uCol);
                        }

                        const colsInUniverse = getUniverseCols(uRow, uCol);
                        const rowsInUniverse = getUniverseRows(uRow, uCol);
                        const universeNum = (uRow * universeGrid.universesH) + uCol + 1;

                        const centerX = offsetX + ((currentX + colsInUniverse / 2) * baseCellSize * scale);
                        const centerY = offsetY + ((currentY + rowsInUniverse / 2) * baseCellSize * scale);

                        const fontSize = Math.min(baseCellSize * 3 * scale, 120);
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 4;
                        ctx.strokeText(`U${universeNum}`, centerX, centerY);

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillText(`U${universeNum}`, centerX, centerY);
                    }
                }
            }
        }

        // Draw the grid with zoom and pan (dynamic rendering)
        function drawGridPreview(universesH, universesV, colors, colsPerUniverse, rowsPerUniverse) {
            const canvas = document.getElementById('gridCanvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get canvas context!');
                return;
            }

            // Set canvas to full window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Clear canvas with background color
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate total dimensions in cells
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            // Calculate scale to fit all content in viewport
            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;

            // Calculate display dimensions
            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;

            // Center offset plus pan
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;

            // Draw the dynamic grid with alpha
            const mapAlpha = parseFloat(document.getElementById('mapAlpha')?.value || 100) / 100;
            if (mapAlpha > 0) {
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                drawDynamicGrid(ctx, offsetX, offsetY, scale, colors, mapAlpha);
                ctx.globalAlpha = 1.0; // Reset alpha for other elements
            }

            // Draw cable groups if enabled
            const showCables = document.getElementById('showCableGroups')?.checked;
            if (showCables && pointCloudLoaded && cableGroups.length > 0) {
                const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
                const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
                drawCableGroups(ctx, offsetX, offsetY, scale, pointScale, pointOffsetX, pointOffsetY);
            }

            // Draw point cloud overlay if enabled
            const showPoints = document.getElementById('showPointCloud')?.checked;
            if (showPoints && pointCloudLoaded && pointCloudData.length > 0) {
                const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                const pointSize = parseFloat(document.getElementById('pointSize')?.value || 20);
                const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
                const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
                drawPointCloud(ctx, offsetX, offsetY, scale, pointScale, pointSize, pointOffsetX, pointOffsetY);
            }

            // Draw row and column headers if enabled
            const showHeaders = document.getElementById('showRowColHeaders')?.checked;
            if (showHeaders) {
                drawRowColHeaders(ctx, offsetX, offsetY, scale, totalCols, totalRows);
            }

            // Draw crosshair if enabled
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair && currentMouseX >= 0 && currentMouseY >= 0) {
                // Calculate which cell the mouse is over
                const gridX = (currentMouseX - offsetX) / scale;
                const gridY = (currentMouseY - offsetY) / scale;
                const cellCol = Math.floor(gridX / baseCellSize);
                const cellRow = Math.floor(gridY / baseCellSize);

                // Only pass valid cell coordinates (within grid bounds)
                const validCellCol = (cellCol >= 0 && cellCol < totalCols) ? cellCol : null;
                const validCellRow = (cellRow >= 0 && cellRow < totalRows) ? cellRow : null;

                drawCrosshair(ctx, currentMouseX, currentMouseY, canvas.width, canvas.height, validCellRow, validCellCol);
            }

            // Update zoom label
            const zoomLabel = document.getElementById('zoomLevel');
            if (zoomLabel) {
                zoomLabel.textContent = Math.round(zoom * 100) + '%';
            }
        }

        // Update preview
        function updatePreview() {
            try {

                const cols = parseInt(document.getElementById('cols').value) || 20;
                const rows = parseInt(document.getElementById('rows').value) || 10;
                const universesH = parseInt(document.getElementById('universes_h').value) || 6;
                const universesV = parseInt(document.getElementById('universes_v').value) || 5;


                // Initialize universe grid if not already initialized or if dimensions changed
                if (universeGrid.universes.length === 0 ||
                    universeGrid.universesH !== universesH ||
                    universeGrid.universesV !== universesV) {
                    initializeUniverseGrid(cols, rows, universesH, universesV);
                }

                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const totalUniverses = universesH * universesV;

                // Calculate average cells per universe
                let totalCellsInAllUniverses = 0;
                for (let uRow = 0; uRow < universesV; uRow++) {
                    for (let uCol = 0; uCol < universesH; uCol++) {
                        const cols = getUniverseCols(uRow, uCol);
                        const rows = getUniverseRows(uRow, uCol);
                        totalCellsInAllUniverses += cols * rows;
                    }
                }
                const cellsPerUniverse = Math.round(totalCellsInAllUniverses / totalUniverses);
                const totalCells = totalCols * totalRows;

                // Update stats
                const elem1 = document.getElementById('totalUniverses');
                const elem2 = document.getElementById('gridSize');
                const elem3 = document.getElementById('cellsPerUniverse');
                const elem4 = document.getElementById('totalCells');

                if (elem1) {
                    elem1.textContent = totalUniverses;
                } else {
                    console.error('totalUniverses element not found');
                }

                if (elem2) {
                    elem2.textContent = `${totalRows + 1} √ó ${totalCols + 1}`;
                } else {
                    console.error('gridSize element not found');
                }

                if (elem3) {
                    elem3.textContent = cellsPerUniverse.toLocaleString();
                } else {
                    console.error('cellsPerUniverse element not found');
                }

                if (elem4) {
                    elem4.textContent = totalCells.toLocaleString();
                } else {
                    console.error('totalCells element not found');
                }

                // Update Version Display
                const versionDisplay = document.getElementById('appVersion');
                if (!versionDisplay) {
                    const vDiv = document.createElement('div');
                    vDiv.id = 'appVersion';
                    vDiv.style.position = 'absolute';
                    vDiv.style.bottom = '10px';
                    vDiv.style.right = '10px';
                    vDiv.style.color = 'rgba(255,255,255,0.3)';
                    vDiv.style.fontFamily = 'monospace';
                    vDiv.style.fontSize = '12px';
                    vDiv.textContent = 'v.2025.01.09.9';
                    document.body.appendChild(vDiv);
                } else {
                    versionDisplay.textContent = 'v.2025.01.09.9';
                }

                // Calculate cable groups if we have points (needed for box numbers in cells)
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    calculateCableGroups();
                }

                // Draw visual preview with cells
                const colors = generateUniverseColors(totalUniverses);
                drawGridPreview(universesH, universesV, colors, cols, rows);

            } catch (error) {
                console.error('Preview update error:', error);
            }
        }

        // Generate cell label with custom data support
        function generateCellLabel(rowInUniverse, colInUniverse, universeNum, boxNum = null, cellRow = null, cellCol = null) {
            // Check for custom cell data
            let customData = null;
            if (cellRow !== null && cellCol !== null) {
                const cellKey = `${cellRow},${cellCol}`;
                customData = cellCustomData.get(cellKey);
            }

            if (customData) {
                // Use custom data with combined U-B format (same as default)
                const indexLabel = customData.index || `${colInUniverse + 1}`;
                const universeLabel = customData.universe ? `U${customData.universe}` : `U${universeNum}`;
                let bLabel = '';
                if (customData.box) {
                    bLabel = `B${customData.box}`;
                } else if (boxNum !== null && boxNum !== undefined) {
                    bLabel = `B${boxNum}`;
                } else {
                    // Only show 'B' if this cell actually has a point
                    const cellKey = `${cellRow},${cellCol}`;
                    const point = pointCloudData.find(p => p.cellKey === cellKey);
                    if (point) {
                        bLabel = 'B';
                    }
                }

                // Construct result - only add B line if bLabel is non-empty
                let result = `${indexLabel}\n${universeLabel}\n`;
                if (bLabel) {
                    result += bLabel + '\n';
                }

                // Append note if it exists and is a genuine user note (not just cell content patterns)
                if (customData.note) {
                    // Filter out notes that are just cell content patterns
                    // These patterns indicate the note is just accumulated cell data, not a real user note
                    const isJustCellPattern = /^(U\d+\n?B\d*|B\d*|U\d+-B\d*|\d+\s*‚óè?|‚óè\s*\d+)$/i.test(customData.note.trim());
                    if (!isJustCellPattern && customData.note.trim() !== '') {
                        result += customData.note + '\n';
                    }
                }
                return result;
            } else {
                // Default format
                const colLabel = `${colInUniverse + 1}`;
                const universeLabel = `U${universeNum}`;

                // Only show 'B' if this cell actually has a point
                let bLabel = '';
                if (boxNum !== null) {
                    bLabel = `B${boxNum}`;
                } else if (cellRow !== null && cellCol !== null) {
                    const cellKey = `${cellRow},${cellCol}`;
                    const point = pointCloudData.find(p => p.cellKey === cellKey);
                    if (point) {
                        bLabel = 'B';
                    }
                }

                let result = `${colLabel}\n${universeLabel}\n`;
                if (bLabel) {
                    result += bLabel + '\n';
                }
                return result;
            }
        }

        // Generate map data using actual universe grid structure (respects custom boundaries)
        function generateMapData() {
            // Calculate total dimensions from actual universe grid
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();

            const grid = [];

            // Header row
            const headerRow = [''];
            for (let col = 0; col < totalCols; col++) {
                headerRow.push(`C${col + 1}`);
            }
            grid.push(headerRow);

            // Data rows - using dynamic universe grid
            for (let row = 0; row < totalRows; row++) {
                const rowData = [`R${row + 1}`];

                // For each column, determine which universe and position within that universe
                for (let col = 0; col < totalCols; col++) {
                    // Find which universe this cell belongs to
                    let cellValue = '';
                    let foundUniverse = false;

                    for (let uRow = 0; uRow < universeGrid.universesV && !foundUniverse; uRow++) {
                        for (let uCol = 0; uCol < universeGrid.universesH && !foundUniverse; uCol++) {
                            // Calculate X position by summing widths in the SAME ROW
                            let currentX = 0;
                            for (let c = 0; c < uCol; c++) {
                                currentX += getUniverseCols(uRow, c);
                            }

                            // Calculate Y position by summing heights in the SAME COLUMN
                            let currentY = 0;
                            for (let r = 0; r < uRow; r++) {
                                currentY += getUniverseRows(r, uCol);
                            }

                            const colsInUniverse = getUniverseCols(uRow, uCol);
                            const rowsInUniverse = getUniverseRows(uRow, uCol);

                            // Check if this cell is in this universe
                            if (col >= currentX && col < currentX + colsInUniverse &&
                                row >= currentY && row < currentY + rowsInUniverse) {

                                const colInUniverse = col - currentX;
                                const rowInUniverse = row - currentY + 1; // +1 because B1, B2, etc.
                                const universeNum = (uRow * universeGrid.universesH) + uCol + 1;

                                // Get box number for this cell
                                const cellKey = `${row},${col}`;
                                const boxNum = cellToBoxNumber.get(cellKey);

                                cellValue = generateCellLabel(rowInUniverse, colInUniverse, universeNum, boxNum, row, col);
                                foundUniverse = true;
                            }
                        }
                    }

                    rowData.push(cellValue);
                }

                grid.push(rowData);
            }

            return grid;
        }

        // RGB to hex
        function rgbToHex(r, g, b) {
            return [r, g, b].map(x => {
                const hex = Math.round(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }

        // Hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Apply transparency to color
        function applyTransparency(hexColor, opacity = 0.8) {
            const rgb = hexToRgb(hexColor);
            if (!rgb) return hexColor;

            // Blend with white background
            const r = Math.round(rgb.r * opacity + 255 * (1 - opacity));
            const g = Math.round(rgb.g * opacity + 255 * (1 - opacity));
            const b = Math.round(rgb.b * opacity + 255 * (1 - opacity));

            return rgbToHex(r, g, b);
        }

        // Generate Excel file
        function generateExcel(event) {
            event.preventDefault();

            const loading = document.getElementById('loading');
            const submitBtn = document.querySelector('button[type="submit"]');
            const errorBox = document.getElementById('errorBox');

            loading.classList.add('show');
            submitBtn.disabled = true;
            errorBox.classList.remove('show');

            try {
                const cols = parseInt(document.getElementById('cols').value);
                const rows = parseInt(document.getElementById('rows').value);
                const universesH = parseInt(document.getElementById('universes_h').value);
                const universesV = parseInt(document.getElementById('universes_v').value);

                // Ensure cable groups are calculated (uses same logic as visual display)
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    calculateCableGroups();
                }

                // Map points to cells using EXACT same logic as visual rendering
                const cellsWithPoints = new Map(); // key: "row,col", value: { left: bool, boxNum: number }
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                    const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
                    const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
                    const baseCellSize = 60; // Same as rendering
                    const csvWidth = pointCloudBounds ? (pointCloudBounds.maxX - pointCloudBounds.minX) : 0;
                    const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;

                    pointCloudData.forEach((point, idx) => {
                        let cellCol, cellRow;
                        let isOffsetLeft = true;

                        if (point.isImported) {
                            // Imported points: use stored cell positions directly (no transformation)
                            cellCol = point.cellCol;
                            cellRow = point.cellRow;
                            // Use stored stagger info
                            isOffsetLeft = (point.xStagger || 0) < 0;  // Negative stagger = left
                        } else {
                            // CSV points: transform coordinates to cell positions
                            const relativeX = point.x - pointCloudBounds.minX;
                            const relativeY = point.y - pointCloudBounds.minY;

                            // Convert to grid pixel space
                            const gridPixelX = relativeX * baseCellSize * pointScale;
                            const gridPixelY = relativeY * baseCellSize * pointScale;

                            // Flip Y coordinate
                            const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                            // Apply offsets (in grid space)
                            const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                            const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                            // Convert to cell indices (each cell is baseCellSize pixels)
                            cellCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                            cellRow = Math.floor(gridPixelYFlippedWithOffset / baseCellSize);

                            // Determine stagger from CSV row
                            if (!point.isCreated && pointCloudPitch && pointCloudPitch.y > 0) {
                                const csvRowIndex = Math.floor((point.y - pointCloudBounds.minY) / pointCloudPitch.y);
                                isOffsetLeft = csvRowIndex % 2 !== 0;  // Odd rows = left
                            }
                        }

                        // Add 1 to account for header row/col in Excel
                        const excelRow = cellRow + 1;
                        const excelCol = cellCol + 1;

                        // Get box number from the cellToBoxNumber map (populated by calculateCableGroups)
                        const cellKey = `${cellRow},${cellCol}`;
                        const boxNum = cellToBoxNumber.get(cellKey);

                        const key = `${excelRow},${excelCol}`;
                        // Include all points, even those without B number (boxNum will be undefined)
                        cellsWithPoints.set(key, { left: isOffsetLeft, boxNum: boxNum });
                    });

                }

                // Calculate which cells contain green boxes
                const cellsWithBoxes = new Map(); // key: "excelRow,excelCol", value: { universeNum, groupNum }
                if (cableGroups.length > 0) {
                    const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                    const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
                    const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
                    const baseCellSize = 60;
                    const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;

                    console.log('EXPORT - Building cellsWithBoxes, customBoxPositions count:', customBoxPositions.size);
                    cableGroups.forEach(group => {
                        const boxKey = `${group.universeNum}-${group.groupInUniverse}`;
                        let cellCol, cellRow;
                        let posSource = 'calculated';

                        if (customBoxPositions.has(boxKey)) {
                            // Use custom position (stored in grid pixel space)
                            const customPos = customBoxPositions.get(boxKey);
                            cellCol = Math.floor(customPos.x / baseCellSize);
                            cellRow = Math.floor(customPos.y / baseCellSize);
                            posSource = 'custom';
                        } else if (group.center.isImported) {
                            // Imported group: center x,y are already in cell coordinates
                            cellCol = Math.floor(group.center.x);
                            cellRow = Math.floor(group.center.y);
                        } else {
                            // CSV group: transform center coordinates to cell positions
                            const relativeX = group.center.x - pointCloudBounds.minX;
                            const relativeY = group.center.y - pointCloudBounds.minY;
                            const gPixelX = relativeX * baseCellSize * pointScale;
                            const gPixelY = relativeY * baseCellSize * pointScale;
                            const gPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gPixelY;
                            const gridPixelX = gPixelX + pointOffsetX;
                            const gridPixelY = gPixelYFlipped + pointOffsetY;
                            cellCol = Math.floor(gridPixelX / baseCellSize);
                            cellRow = Math.floor(gridPixelY / baseCellSize);
                        }

                        // Excel uses 1-based indexing and has header row/col
                        const excelRow = cellRow + 1;
                        const excelCol = cellCol + 1;

                        const key = `${excelRow},${excelCol}`;
                        cellsWithBoxes.set(key, {
                            universeNum: group.universeNum,
                            groupNum: group.groupInUniverse
                        });
                        // Log first few box positions
                        if (group.universeNum <= 3 && group.groupInUniverse <= 2) {
                            console.log(`EXPORT - Box ${boxKey} at cell (${cellRow},${cellCol}) [source: ${posSource}]`);
                        }
                    });

                    // Log green box counts per universe for debugging
                    const boxCountsByUniverse = new Map();
                    cableGroups.forEach(g => {
                        const count = boxCountsByUniverse.get(g.universeNum) || 0;
                        boxCountsByUniverse.set(g.universeNum, count + 1);
                    });
                    console.log('EXPORT - Green boxes per universe:', Object.fromEntries(boxCountsByUniverse));
                    console.log('EXPORT - Total cableGroups:', cableGroups.length);
                    console.log('EXPORT - customBoxPositions count:', customBoxPositions.size);

                    // Debug U1 specifically - show cell positions for comparison with import
                    const u1Group = cableGroups.find(g => g.universeNum === 1);
                    if (u1Group) {
                        // Get cell positions for U1 points
                        const u1CellPositions = u1Group.points.map(p => {
                            if (p.isImported) {
                                // Imported points: use stored cell positions
                                return { cellRow: p.cellRow, cellCol: p.cellCol };
                            } else {
                                // CSV points: calculate from coordinates
                                const relX = p.x - pointCloudBounds.minX;
                                const relY = p.y - pointCloudBounds.minY;
                                const gPixelX = relX * baseCellSize * pointScale + pointOffsetX;
                                const gPixelYFlip = (csvHeight * baseCellSize * pointScale) - (relY * baseCellSize * pointScale) + pointOffsetY;
                                return {
                                    cellRow: Math.floor(gPixelYFlip / baseCellSize),
                                    cellCol: Math.floor(gPixelX / baseCellSize)
                                };
                            }
                        });
                        console.log('EXPORT - U1 group:', {
                            boxNum: u1Group.groupInUniverse,
                            numPoints: u1Group.points.length,
                            center: u1Group.center,
                            isImported: u1Group.center.isImported
                        });
                        // Log all U1 cell positions for direct comparison with PARSE
                        console.log('EXPORT - U1 cell positions (cellRow, cellCol):', u1CellPositions);
                        console.log('EXPORT - pointCloudBounds:', pointCloudBounds);
                        console.log('EXPORT - scale:', pointScale, 'offsetX:', pointOffsetX, 'offsetY:', pointOffsetY);
                    }
                }

                // Generate the grid data
                const grid = generateMapData();

                // Generate colors for universes
                const totalUniverses = universesH * universesV;
                const colors = generateUniverseColors(totalUniverses);

                // Create workbook with cell styles option
                const wb = XLSX.utils.book_new();
                wb.Props = {
                    Title: "Spread-Map",
                    Author: "Spread-Map Generator"
                };

                // Create worksheet manually to have better control
                const ws = {};
                const range = {
                    s: { c: 0, r: 0 },
                    e: { c: grid[0].length - 1, r: grid.length - 1 }
                };

                // Fill worksheet with data and styling
                for (let R = 0; R < grid.length; R++) {
                    for (let C = 0; C < grid[R].length; C++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                        let cellValue = grid[R][C];

                        // Check if this cell has a point
                        const pointKey = `${R},${C}`;
                        const cellKey = `${R - 1},${C - 1}`; // Convert to 0-based for cellCustomData
                        const customData = cellCustomData.get(cellKey);

                        if (cellsWithPoints.has(pointKey) && R > 0 && C > 0) {
                            const pointInfo = cellsWithPoints.get(pointKey);

                            // Both custom and default format now use combined U#-B# on line 2
                            const lines = cellValue.split('\n');
                            if (lines.length >= 2) {
                                // Add dot on first line
                                if (pointInfo.left) {
                                    lines[0] = '‚óè ' + lines[0];
                                } else {
                                    lines[0] = lines[0] + ' ‚óè';
                                }

                                // Update the B number
                                if (pointInfo.boxNum) {
                                    // Check for 3-line format (Index, U, B)
                                    if (lines.length > 2 && lines[2].trim().startsWith('B')) {
                                        lines[2] = `B${pointInfo.boxNum}`;
                                    }
                                    // Fallback for 2-line format (Index, U-B)
                                    else if (lines.length > 1) {
                                        lines[1] = lines[1].replace(/B\d*/, `B${pointInfo.boxNum}`);
                                    }
                                }

                                cellValue = lines.join('\n');
                            }
                        }

                        // Check if this cell contains a green box (cable group center)
                        const boxCellKey = `${R},${C}`;
                        if (cellsWithBoxes.has(boxCellKey) && R > 0 && C > 0) {
                            const boxInfo = cellsWithBoxes.get(boxCellKey);
                            // Add box label to cell content
                            // CRITICAL FIX: Include Universe ID in the box marker to ensure correct universe assignment
                            // regardless of which cell/universe area the box is actually placed in.
                            // Format: Box-U<UniNum>-<GroupNum> (e.g., Box-U1-1)
                            cellValue = `Box-U${boxInfo.universeNum}-${boxInfo.groupNum}\n${cellValue}`;
                        }

                        const cell = {
                            v: cellValue,
                            t: 's', // string type
                            s: {}
                        };

                        // Common styles
                        cell.s = {
                            alignment: {
                                horizontal: 'center',
                                vertical: 'top',
                                wrapText: true
                            },
                            border: {
                                top: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                bottom: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                left: { style: 'thin', color: { rgb: 'D3D3D3' } },
                                right: { style: 'thin', color: { rgb: 'D3D3D3' } }
                            },
                            font: { sz: 9, name: 'Arial' }
                        };

                        // Header styling
                        if (R === 0 || C === 0) {
                            cell.s.fill = {
                                patternType: 'solid',
                                fgColor: { rgb: 'D3D3D3' }
                            };
                            cell.s.font.bold = true;
                            cell.s.alignment.vertical = 'center';
                        } else {
                            // Data cell - extract universe number and apply color
                            if (typeof cellValue === 'string' && cellValue.includes('U')) {
                                const match = cellValue.match(/U(\d+)/);
                                if (match) {
                                    const universeNum = parseInt(match[1]);
                                    if (colors[universeNum]) {
                                        // Check if this cell has a point and/or B assignment
                                        const pointKey = `${R},${C}`;
                                        const pointInfo = cellsWithPoints.get(pointKey);
                                        const hasPoint = !!pointInfo;
                                        const hasBoxNum = pointInfo && pointInfo.boxNum !== undefined;

                                        // Different opacity levels:
                                        // - Point with B number: 0.8 (full)
                                        // - Point without B number: 0.5 (medium)
                                        // - No point: 0.15 (very transparent)
                                        let opacity = 0.15;
                                        if (hasPoint) {
                                            opacity = hasBoxNum ? 0.8 : 0.5;
                                        }

                                        const transparentColor = applyTransparency(colors[universeNum], opacity);
                                        cell.s.fill = {
                                            patternType: 'solid',
                                            fgColor: { rgb: transparentColor }
                                        };
                                    }
                                }
                            }

                            // Override styling for cells containing green boxes
                            if (cellsWithBoxes.has(boxCellKey)) {
                                cell.s.fill = {
                                    patternType: 'solid',
                                    fgColor: { rgb: '22C55E' } // Green to match the visual boxes
                                };
                                cell.s.font = { sz: 9, name: 'Arial', bold: true, color: { rgb: 'FFFFFF' } };
                                cell.s.border = {
                                    top: { style: 'thick', color: { rgb: '000000' } },
                                    bottom: { style: 'thick', color: { rgb: '000000' } },
                                    left: { style: 'thick', color: { rgb: '000000' } },
                                    right: { style: 'thick', color: { rgb: '000000' } }
                                };
                            }
                        }

                        ws[cellAddress] = cell;
                    }
                }

                ws['!ref'] = XLSX.utils.encode_range(range);

                // Set column widths and row heights for square cells
                // Excel uses different units: row height in points, column width in character units
                // To create square cells: 50pt height ‚âà 7.5 character width
                const colWidths = [];
                for (let i = 0; i < grid[0].length; i++) {
                    colWidths.push({ wch: 7.5 });
                }
                ws['!cols'] = colWidths;

                const rowHeights = [];
                for (let i = 0; i < grid.length; i++) {
                    rowHeights.push({ hpt: 50 });
                }
                ws['!rows'] = rowHeights;

                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Spread-Map');

                // Generate file and download with cellStyles option
                XLSX.writeFile(wb, 'spread-map.xlsx', { cellStyles: true, bookType: 'xlsx' });

                // Also generate PDF if checkbox is checked
                if (document.getElementById('exportPDF').checked) {
                    generatePDF();
                }

                loading.classList.remove('show');
                submitBtn.disabled = false;

            } catch (error) {
                console.error('Generation error:', error);
                errorBox.textContent = '‚ö†Ô∏è Error: ' + error.message;
                errorBox.classList.add('show');
                loading.classList.remove('show');
                submitBtn.disabled = false;
            }
        }

        // Generate PDF from the full map (not zoomed view)
        function generatePDF() {
            try {
                const { jsPDF } = window.jspdf;

                // Calculate full map dimensions
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;

                // Add space for edge labels
                const labelMargin = 30; // Space for row/column labels
                const canvasWidth = gridPixelWidth + (2 * labelMargin);
                const canvasHeight = gridPixelHeight + (2 * labelMargin);

                // Create a temporary canvas for the full map
                const tempCanvas = document.createElement('canvas');
                const scale = 2; // High resolution for quality
                tempCanvas.width = canvasWidth * scale;
                tempCanvas.height = canvasHeight * scale;
                const ctx = tempCanvas.getContext('2d');

                // Scale for high resolution
                ctx.scale(scale, scale);

                // Fill background
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Draw column labels (top and bottom)
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let col = 0; col < totalCols; col++) {
                    const x = labelMargin + col * baseCellSize + baseCellSize / 2;
                    // Top labels
                    ctx.fillText(`C${col + 1}`, x, labelMargin / 2);
                    // Bottom labels
                    ctx.fillText(`C${col + 1}`, x, canvasHeight - labelMargin / 2);
                }

                // Draw row labels (left and right)
                for (let row = 0; row < totalRows; row++) {
                    const y = labelMargin + row * baseCellSize + baseCellSize / 2;
                    // Left labels
                    ctx.fillText(`R${row + 1}`, labelMargin / 2, y);
                    // Right labels
                    ctx.fillText(`R${row + 1}`, canvasWidth - labelMargin / 2, y);
                }

                // Generate colors
                const universesH = parseInt(document.getElementById('universes_h').value);
                const universesV = parseInt(document.getElementById('universes_v').value);
                const totalUniverses = universesH * universesV;
                const colors = generateUniverseColors(totalUniverses);

                // Draw cells at full size (no zoom, no pan) - offset by labelMargin
                for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                    for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                        const cellUniverse = getCellUniverse(cellCol, cellRow);
                        if (!cellUniverse) continue;

                        const universeNum = cellUniverse.universeNum;
                        const hexColor = colors[universeNum] || 'CCCCCC';

                        const x = labelMargin + cellCol * baseCellSize;
                        const y = labelMargin + cellRow * baseCellSize;

                        // Fill cell
                        ctx.fillStyle = '#' + hexColor;
                        ctx.fillRect(x, y, baseCellSize, baseCellSize);

                        // Draw border
                        ctx.strokeStyle = '#555';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x, y, baseCellSize, baseCellSize);

                        // Draw cell ID
                        ctx.fillStyle = 'rgba(0, 0, 128, 0.7)';
                        ctx.font = '6px monospace';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`${cellRow + 1},${cellCol + 1}`, x + 2, y + 2);

                        // Draw cell content
                        const cellKey = `${cellRow},${cellCol}`;
                        const customData = cellCustomData.get(cellKey);
                        const boxNum = cellToBoxNumber.get(cellKey);

                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';

                        if (customData) {
                            let yOffset = y + 12;
                            if (customData.index) {
                                ctx.textBaseline = 'top';
                                ctx.fillText(customData.index, x + baseCellSize / 2, yOffset);
                                yOffset += 10;
                            }
                            if (customData.universe) {
                                ctx.font = 'bold 8px Arial';
                                ctx.fillText(`U${customData.universe}`, x + baseCellSize / 2, yOffset);
                                yOffset += 10;
                            }
                            if (customData.box) {
                                ctx.font = '8px Arial';
                                ctx.fillText(`B${customData.box}`, x + baseCellSize / 2, yOffset);
                            } else if (boxNum !== undefined) {
                                ctx.font = '8px Arial';
                                ctx.fillText(`B${boxNum}`, x + baseCellSize / 2, yOffset);
                            }
                        } else {
                            ctx.textBaseline = 'top';
                            ctx.fillText(`${cellUniverse.cellInUniverseCol + 1}`, x + baseCellSize / 2, y + 12);
                            ctx.font = 'bold 8px Arial';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`U${universeNum}`, x + baseCellSize / 2, y + baseCellSize / 2);
                            ctx.font = '8px Arial';
                            ctx.textBaseline = 'bottom';
                            const bLabel = boxNum !== undefined ? `B${boxNum}` : 'B';
                            ctx.fillText(bLabel, x + baseCellSize / 2, y + baseCellSize - 5);
                        }
                    }
                }

                // Draw universe boundaries - offset by labelMargin
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                for (let cellRow = 0; cellRow < totalRows; cellRow++) {
                    for (let cellCol = 0; cellCol < totalCols; cellCol++) {
                        const cellUniverse = getCellUniverse(cellCol, cellRow);
                        if (!cellUniverse) continue;

                        const x = labelMargin + cellCol * baseCellSize;
                        const y = labelMargin + cellRow * baseCellSize;

                        const rightNeighbor = getCellUniverse(cellCol + 1, cellRow);
                        if (!rightNeighbor || rightNeighbor.universeNum !== cellUniverse.universeNum) {
                            ctx.beginPath();
                            ctx.moveTo(x + baseCellSize, y);
                            ctx.lineTo(x + baseCellSize, y + baseCellSize);
                            ctx.stroke();
                        }

                        const bottomNeighbor = getCellUniverse(cellCol, cellRow + 1);
                        if (!bottomNeighbor || bottomNeighbor.universeNum !== cellUniverse.universeNum) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + baseCellSize);
                            ctx.lineTo(x + baseCellSize, y + baseCellSize);
                            ctx.stroke();
                        }
                    }
                }

                // Draw points and cable groups if loaded - offset by labelMargin
                if (pointCloudLoaded && pointCloudData.length > 0) {
                    const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
                    const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
                    const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
                    const pointSize = parseFloat(document.getElementById('pointSize')?.value || 7);
                    const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;

                    // Helper to convert point to grid position (with labelMargin offset)
                    function pointToGrid(point) {
                        const relativeX = point.x - pointCloudBounds.minX;
                        const relativeY = point.y - pointCloudBounds.minY;
                        const gridPixelX = relativeX * baseCellSize * pointScale + pointOffsetX + labelMargin;
                        const gridPixelY = relativeY * baseCellSize * pointScale;
                        const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY + pointOffsetY + labelMargin;
                        return { x: gridPixelX, y: gridPixelYFlipped };
                    }

                    // Draw cable group lines
                    cableGroups.forEach(group => {
                        const boxKey = `${group.universeNum}-${group.groupInUniverse}`;
                        let boxX, boxY;

                        if (customBoxPositions.has(boxKey)) {
                            // Custom position is in grid pixel space - add labelMargin
                            boxX = customBoxPositions.get(boxKey).x + labelMargin;
                            boxY = customBoxPositions.get(boxKey).y + labelMargin;
                        } else {
                            const centerPos = pointToGrid(group.center);
                            boxX = centerPos.x;
                            boxY = centerPos.y;
                        }

                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.lineWidth = 1.5;

                        group.points.forEach(point => {
                            const pos = pointToGrid(point);
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                            ctx.lineTo(boxX, boxY);
                            ctx.stroke();
                        });

                        // Draw box
                        const markerWidth = 40;
                        const markerHeight = 20;
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
                        ctx.fillRect(boxX - markerWidth / 2, boxY - markerHeight / 2, markerWidth, markerHeight);
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(boxX - markerWidth / 2, boxY - markerHeight / 2, markerWidth, markerHeight);

                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`U${group.universeNum}-${group.groupInUniverse}`, boxX, boxY);
                    });

                    // Draw points
                    pointCloudData.forEach(point => {
                        const pos = pointToGrid(point);
                        // Cell calculation needs to account for labelMargin offset
                        const cellCol = Math.floor((pos.x - labelMargin) / baseCellSize);
                        const cellRow = Math.floor((pos.y - labelMargin) / baseCellSize);
                        const cellKey = `${cellRow},${cellCol}`;
                        const customData = cellCustomData.get(cellKey);
                        const hasBoxNumber = cellToBoxNumber.has(cellKey);

                        if (customData && customData.box === '' && !hasBoxNumber) return;

                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, pointSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    });
                }

                // Determine PDF orientation based on full canvas (with labels)
                const isLandscape = canvasWidth > canvasHeight;
                const orientation = isLandscape ? 'landscape' : 'portrait';

                // Create PDF
                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: 'a3'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const pdfMargin = 10;
                const availableWidth = pageWidth - (2 * pdfMargin);
                const availableHeight = pageHeight - (2 * pdfMargin);

                const scaleX = availableWidth / canvasWidth;
                const scaleY = availableHeight / canvasHeight;
                const pdfScale = Math.min(scaleX, scaleY);

                const imgWidth = canvasWidth * pdfScale;
                const imgHeight = canvasHeight * pdfScale;
                const offsetX = (pageWidth - imgWidth) / 2;
                const offsetY = (pageHeight - imgHeight) / 2;

                // Convert canvas to image
                const imgData = tempCanvas.toDataURL('image/png', 1.0);
                pdf.addImage(imgData, 'PNG', offsetX, offsetY, imgWidth, imgHeight);

                // Add title
                pdf.setFontSize(10);
                pdf.setTextColor(100);
                pdf.text('Spread-Map Export', pdfMargin, pdfMargin - 2);

                pdf.save('spread-map.pdf');

            } catch (error) {
                console.error('PDF generation error:', error);
            }
        }

        // Event listeners
        document.getElementById('mapForm').addEventListener('submit', generateExcel);

        // Auto-update for all inputs except grid layout fields and CSV upload
        document.querySelectorAll('input:not(#csvFileInput):not(#cols):not(#rows):not(#universes_h):not(#universes_v)').forEach(input => {
            input.addEventListener('input', () => {
                updatePreview();
                saveSettings();
            });
            input.addEventListener('change', () => {
                updatePreview();
                saveSettings();
            });
        });

        // Grid layout fields - only save on change, don't auto-update preview
        ['cols', 'rows', 'universes_h', 'universes_v'].forEach(id => {
            document.getElementById(id).addEventListener('change', saveSettings);
        });

        // Apply button for grid layout changes
        document.getElementById('applyGridBtn').addEventListener('click', () => {
            // Enable cell text generation
            universeGrid.showCellText = true;

            // Get current dimensions from input fields
            const cols = parseInt(document.getElementById('cols').value) || 20;
            const rows = parseInt(document.getElementById('rows').value) || 10;
            const universesH = parseInt(document.getElementById('universes_h').value) || 6;
            const universesV = parseInt(document.getElementById('universes_v').value) || 5;

            // Check if grid dimensions have changed (requires reset)
            const dimensionsChanged =
                universeGrid.universes.length === 0 ||
                universeGrid.universesH !== universesH ||
                universeGrid.universesV !== universesV ||
                (universeGrid.universes.length > 0 &&
                    universeGrid.universes[0].length > 0 &&
                    (universeGrid.universes[0][0].cols !== cols ||
                        universeGrid.universes[0][0].rows !== rows));

            if (dimensionsChanged) {
                // Reset universe boundaries to uniform dimensions
                console.log('Grid dimensions changed - resetting universe boundaries');
                initializeUniverseGrid(cols, rows, universesH, universesV);
            } else {
                console.log('Grid dimensions unchanged - keeping custom boundaries');
            }

            // Always recalculate cable groups based on current grid layout
            if (pointCloudLoaded && pointCloudData.length > 0) {
                calculateCableGroups();
            }

            updatePreview();
            saveSettings();
        });

        // Spreadsheet file upload handler (CSV or Excel)
        document.getElementById('csvFileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const fileInput = e.target; // Save reference to reset after processing
            if (file) {
                const fileName = file.name.toLowerCase();
                const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');

                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        if (isExcel) {
                            // Parse Excel file
                            const data = parseExcelFile(event.target.result);
                            const format = detectFileFormat(data, true);

                            console.log('Detected format:', format);

                            if (format === 'exported-map') {
                                // Import exported map - all state is reconstructed from cell content
                                const mapData = parseExportedMap(data.worksheet);
                                importExportedMap(mapData);
                                console.log('Exported map loaded successfully');
                            } else if (format === 'point-cloud') {
                                // Convert Excel to CSV-like data and parse
                                const worksheet = data.worksheet;
                                const csvData = XLSX.utils.sheet_to_csv(worksheet);
                                parseCSV(csvData);
                                updatePreview();
                                console.log('Point cloud Excel loaded successfully');
                            } else {
                                throw new Error('Unknown Excel file format');
                            }
                        } else {
                            // Parse CSV file
                            const csvText = event.target.result;
                            const format = detectFileFormat(csvText, false);

                            if (format === 'point-cloud') {
                                parseCSV(csvText);
                                updatePreview();
                                console.log('Point cloud CSV loaded successfully');
                            } else {
                                throw new Error('CSV format not supported for exported maps. Please use Excel files.');
                            }
                        }
                    } catch (error) {
                        console.error('Failed to parse file:', error);
                        alert('Failed to load file: ' + error.message);
                    }

                    // Reset file input so same file can be selected again
                    fileInput.value = '';
                };

                if (isExcel) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            }
        });

        // Point cloud scale slider value display
        document.getElementById('pointScale').addEventListener('input', function () {
            document.getElementById('pointScaleValue').textContent = parseFloat(this.value).toFixed(2) + 'x';
        });

        // Point size slider value display
        document.getElementById('pointSize').addEventListener('input', function () {
            document.getElementById('pointSizeValue').textContent = this.value + 'px';
        });

        // Point offset sliders value display
        document.getElementById('pointOffsetX').addEventListener('input', function () {
            document.getElementById('pointOffsetXValue').textContent = this.value;
        });

        document.getElementById('pointOffsetY').addEventListener('input', function () {
            document.getElementById('pointOffsetYValue').textContent = this.value;
        });

        // Map alpha slider value display
        document.getElementById('mapAlpha').addEventListener('input', function () {
            document.getElementById('mapAlphaValue').textContent = this.value + '%';
        });

        // GUI toggle functionality
        const guiContainer = document.getElementById('guiContainer');
        const guiToggle = document.getElementById('guiToggle');
        const guiHeader = document.getElementById('guiHeader');

        function toggleGui() {
            guiContainer.classList.toggle('collapsed');
            guiToggle.textContent = guiContainer.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
            // Save state
            localStorage.setItem('guiCollapsed', guiContainer.classList.contains('collapsed'));
        }

        guiToggle.addEventListener('click', function (e) {
            e.stopPropagation();
            toggleGui();
        });

        guiHeader.addEventListener('click', toggleGui);

        // Restore GUI collapsed state
        if (localStorage.getItem('guiCollapsed') === 'true') {
            guiContainer.classList.add('collapsed');
            guiToggle.textContent = '‚ñ∂';
        }

        // Row/column headers checkbox
        document.getElementById('showRowColHeaders').addEventListener('change', function () {
            saveSettings();
            updatePreview();
        });

        // Crosshair checkbox
        document.getElementById('showCrosshair').addEventListener('change', function () {
            saveSettings();
            updatePreview();
        });

        // Export PDF checkbox
        document.getElementById('exportPDF').addEventListener('change', function () {
            saveSettings();
        });

        // Reset point scale button
        document.getElementById('resetPointScale').addEventListener('click', function () {
            if (pointCloudPitch.y > 0) {
                const idealScale = 1 / pointCloudPitch.y;
                document.getElementById('pointScale').value = idealScale.toFixed(3);
                document.getElementById('pointScaleValue').textContent = idealScale.toFixed(2) + 'x';
                saveSettings();
                updatePreview();
                console.log('Reset point scale to ideal:', idealScale.toFixed(3));
            } else {
                alert('No point cloud loaded yet. Please load a CSV file first.');
            }
        });

        // Initialize the application
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                cols: document.getElementById('cols').value,
                rows: document.getElementById('rows').value,
                universesH: document.getElementById('universes_h').value,
                universesV: document.getElementById('universes_v').value,
                mapAlpha: document.getElementById('mapAlpha').value,
                showCableGroups: document.getElementById('showCableGroups').checked,
                showPointCloud: document.getElementById('showPointCloud').checked,
                showRowColHeaders: document.getElementById('showRowColHeaders').checked,
                showCrosshair: document.getElementById('showCrosshair').checked,
                pointScale: document.getElementById('pointScale').value,
                pointSize: document.getElementById('pointSize').value,
                pointOffsetX: document.getElementById('pointOffsetX').value,
                pointOffsetY: document.getElementById('pointOffsetY').value,
                exportPDF: document.getElementById('exportPDF').checked
            };
            localStorage.setItem('spreadMapSettings', JSON.stringify(settings));
        }

        // Load settings from localStorage
        function loadSettings() {
            try {
                const saved = localStorage.getItem('spreadMapSettings');
                if (saved) {
                    const settings = JSON.parse(saved);

                    // Restore values
                    if (settings.cols) document.getElementById('cols').value = settings.cols;
                    if (settings.rows) document.getElementById('rows').value = settings.rows;
                    if (settings.universesH) document.getElementById('universes_h').value = settings.universesH;
                    if (settings.universesV) document.getElementById('universes_v').value = settings.universesV;
                    if (settings.mapAlpha !== undefined) document.getElementById('mapAlpha').value = settings.mapAlpha;
                    if (settings.showCableGroups !== undefined) document.getElementById('showCableGroups').checked = settings.showCableGroups;
                    if (settings.showPointCloud !== undefined) document.getElementById('showPointCloud').checked = settings.showPointCloud;
                    if (settings.showRowColHeaders !== undefined) document.getElementById('showRowColHeaders').checked = settings.showRowColHeaders;
                    if (settings.showCrosshair !== undefined) document.getElementById('showCrosshair').checked = settings.showCrosshair;
                    if (settings.pointScale) document.getElementById('pointScale').value = settings.pointScale;
                    if (settings.pointSize) document.getElementById('pointSize').value = settings.pointSize;
                    if (settings.pointOffsetX !== undefined) document.getElementById('pointOffsetX').value = settings.pointOffsetX;
                    if (settings.pointOffsetY !== undefined) document.getElementById('pointOffsetY').value = settings.pointOffsetY;
                    if (settings.exportPDF !== undefined) document.getElementById('exportPDF').checked = settings.exportPDF;

                    // Update slider displays
                    document.getElementById('mapAlphaValue').textContent = (settings.mapAlpha || 100) + '%';
                    document.getElementById('pointScaleValue').textContent = parseFloat(settings.pointScale || 1).toFixed(2) + 'x';
                    document.getElementById('pointSizeValue').textContent = (settings.pointSize || 20) + 'px';
                    document.getElementById('pointOffsetXValue').textContent = settings.pointOffsetX !== undefined ? settings.pointOffsetX : 17;
                    document.getElementById('pointOffsetYValue').textContent = settings.pointOffsetY !== undefined ? settings.pointOffsetY : 30;
                }
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }

        function initApp() {
            console.log('=== Initializing App ===');
            console.log('Canvas exists:', !!document.getElementById('gridCanvas'));
            console.log('Stats elements exist:', {
                totalUniverses: !!document.getElementById('totalUniverses'),
                gridSize: !!document.getElementById('gridSize'),
                cellsPerUniverse: !!document.getElementById('cellsPerUniverse'),
                totalCells: !!document.getElementById('totalCells')
            });

            // Load saved settings
            loadSettings();

            // Load point cloud data
            loadPointCloud();

            // Initial preview
            updatePreview();

            console.log('=== App Initialized ===');
        }

        // Wait for DOM to be fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

        // Fallback - also try after a delay
        setTimeout(initApp, 100);

        // Redraw on window resize
        let resizeTimeout;
        window.addEventListener('resize', function () {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updatePreview, 200);
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', function () {
            zoom = Math.max(0.8, Math.min(zoom * 1.2, 20));
            updatePreview();
        });

        document.getElementById('zoomOut').addEventListener('click', function () {
            zoom = Math.max(zoom / 1.2, 0.8);
            updatePreview();
        });

        // Mouse wheel zoom (zoom to cursor position)
        document.getElementById('gridCanvas').addEventListener('wheel', function (e) {
            e.preventDefault();

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;

            // Calculate current zoom parameters
            const oldZoom = zoom;
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            const newZoom = Math.max(0.8, Math.min(20, zoom * (1 + delta)));

            // Calculate the mouse position in world space before zoom
            // Use actual grid dimensions instead of cachedGridImage
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);

            const oldScale = baseScale * oldZoom;
            const newScale = baseScale * newZoom;

            const oldGridWidth = gridPixelWidth * oldScale;
            const oldGridHeight = gridPixelHeight * oldScale;
            const newGridWidth = gridPixelWidth * newScale;
            const newGridHeight = gridPixelHeight * newScale;

            const oldBaseOffsetX = (canvas.width - oldGridWidth) / 2;
            const oldBaseOffsetY = (canvas.height - oldGridHeight) / 2;
            const newBaseOffsetX = (canvas.width - newGridWidth) / 2;
            const newBaseOffsetY = (canvas.height - newGridHeight) / 2;

            // Mouse position relative to grid origin before zoom
            const oldOffsetX = oldBaseOffsetX + panX;
            const oldOffsetY = oldBaseOffsetY + panY;
            const worldX = (mouseX - oldOffsetX) / oldScale;
            const worldY = (mouseY - oldOffsetY) / oldScale;

            // Adjust pan so the same world point ends up under the mouse after zoom
            panX = mouseX - newBaseOffsetX - worldX * newScale;
            panY = mouseY - newBaseOffsetY - worldY * newScale;

            zoom = newZoom;
            updatePreview();
        }, { passive: false });

        // Detect if mouse is near a boundary line segment
        function detectBoundaryAtPosition(mouseX, mouseY) {
            const canvas = document.getElementById('gridCanvas');
            const baseCellSize = 60;
            const threshold = 10; // pixels

            // Calculate grid transformation
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;

            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;

            // Check vertical boundaries (between specific universe pairs)
            let currentY = 0;
            for (let uRow = 0; uRow < universeGrid.universesV; uRow++) {
                let currentX = 0;
                const rowsInUniverse = getUniverseRows(uRow, 0);

                for (let uCol = 0; uCol < universeGrid.universesH - 1; uCol++) {
                    const colsInUniverse = getUniverseCols(uRow, uCol);
                    currentX += colsInUniverse;

                    const boundaryX = offsetX + (currentX * baseCellSize * scale);
                    const topY = offsetY + (currentY * baseCellSize * scale);
                    const bottomY = offsetY + ((currentY + rowsInUniverse) * baseCellSize * scale);

                    // Check if mouse is near this vertical boundary segment
                    if (Math.abs(mouseX - boundaryX) < threshold &&
                        mouseY >= topY && mouseY <= bottomY) {
                        return {
                            type: 'vertical',
                            leftURow: uRow,
                            leftUCol: uCol,
                            rightURow: uRow,
                            rightUCol: uCol + 1
                        };
                    }
                }

                currentY += rowsInUniverse;
            }

            // Check horizontal boundaries (between specific universe pairs)
            let currentX = 0;
            for (let uCol = 0; uCol < universeGrid.universesH; uCol++) {
                let currentY = 0;
                const colsInFirstRow = getUniverseCols(0, uCol);

                for (let uRow = 0; uRow < universeGrid.universesV - 1; uRow++) {
                    const rowsInUniverse = getUniverseRows(uRow, uCol);
                    const colsInThisUniverse = getUniverseCols(uRow, uCol);
                    currentY += rowsInUniverse;

                    const boundaryY = offsetY + (currentY * baseCellSize * scale);
                    const leftX = offsetX + (currentX * baseCellSize * scale);
                    const rightX = offsetX + ((currentX + colsInThisUniverse) * baseCellSize * scale);

                    // Check if mouse is near this horizontal boundary segment
                    if (Math.abs(mouseY - boundaryY) < threshold &&
                        mouseX >= leftX && mouseX <= rightX) {
                        return {
                            type: 'horizontal',
                            topURow: uRow,
                            topUCol: uCol,
                            bottomURow: uRow + 1,
                            bottomUCol: uCol
                        };
                    }
                }

                currentX += colsInFirstRow;
            }

            return null;
        }

        // Detect if mouse is over a box marker
        function detectBoxAtPosition(mouseX, mouseY) {
            for (let i = 0; i < cableGroups.length; i++) {
                const group = cableGroups[i];
                if (group.markerBounds) {
                    const b = group.markerBounds;
                    if (mouseX >= b.x && mouseX <= b.x + b.width &&
                        mouseY >= b.y && mouseY <= b.y + b.height) {
                        return { groupIndex: i, group: group };
                    }
                }
            }
            return null;
        }

        // Mouse drag to pan OR drag boundaries OR drag boxes
        const canvas = document.getElementById('gridCanvas');
        canvas.addEventListener('mousedown', function (e) {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;

            // Check for box click first
            const box = detectBoxAtPosition(mouseX, mouseY);
            if (box) {
                draggingBox = {
                    groupIndex: box.groupIndex,
                    group: box.group,
                    startMouseX: mouseX,
                    startMouseY: mouseY
                };
                canvas.style.cursor = 'move';
                return;
            }

            const boundary = detectBoundaryAtPosition(mouseX, mouseY);

            if (boundary) {
                draggingBoundary = boundary;
                dragStartX = mouseX;
                dragStartY = mouseY;
                canvas.style.cursor = boundary.type === 'vertical' ? 'ew-resize' : 'ns-resize';
            } else {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', function (e) {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * cssToCanvasX;
            const mouseY = (e.clientY - rect.top) * cssToCanvasY;

            // Update global mouse position for crosshair
            currentMouseX = mouseX;
            currentMouseY = mouseY;

            // Redraw if crosshair is enabled (for smooth crosshair tracking)
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair && !isDragging && !draggingBoundary && !draggingBox) {
                updatePreview();
            }

            // Handle box dragging
            if (draggingBox) {
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;
                const availableWidth = canvas.width * 0.9;
                const availableHeight = canvas.height * 0.9;
                const scaleX = availableWidth / gridPixelWidth;
                const scaleY = availableHeight / gridPixelHeight;
                const baseScale = Math.min(scaleX, scaleY);
                const scale = baseScale * zoom;

                const gridWidth = gridPixelWidth * scale;
                const gridHeight = gridPixelHeight * scale;
                const baseOffsetX = (canvas.width - gridWidth) / 2;
                const baseOffsetY = (canvas.height - gridHeight) / 2;
                const offsetX = baseOffsetX + panX;
                const offsetY = baseOffsetY + panY;

                // Convert mouse position to grid pixel space
                const gridPixelX = (mouseX - offsetX) / scale;
                const gridPixelY = (mouseY - offsetY) / scale;

                // Store custom position
                const boxKey = `${draggingBox.group.universeNum}-${draggingBox.group.groupInUniverse}`;
                const cellCol = Math.floor(gridPixelX / baseCellSize);
                const cellRow = Math.floor(gridPixelY / baseCellSize);
                customBoxPositions.set(boxKey, { x: gridPixelX, y: gridPixelY });
                console.log(`DRAG - Box ${boxKey} moved to cell (${cellRow}, ${cellCol})`);

                updatePreview();
                return;
            }

            if (draggingBoundary) {
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;
                const availableWidth = canvas.width * 0.9;
                const availableHeight = canvas.height * 0.9;
                const scaleX = availableWidth / gridPixelWidth;
                const scaleY = availableHeight / gridPixelHeight;
                const baseScale = Math.min(scaleX, scaleY);
                const scale = baseScale * zoom;

                if (draggingBoundary.type === 'vertical') {
                    const deltaX = mouseX - dragStartX;
                    const cellDelta = Math.round(deltaX / (baseCellSize * scale));

                    if (cellDelta !== 0) {
                        // Get the two specific universes
                        const leftUni = getUniverse(draggingBoundary.leftURow, draggingBoundary.leftUCol);
                        const rightUni = getUniverse(draggingBoundary.rightURow, draggingBoundary.rightUCol);

                        // Adjust only these two universes with equal and opposite deltas
                        if (leftUni && rightUni) {
                            // Calculate the actual delta that can be applied (constrained by minimums)
                            let actualDelta;
                            if (cellDelta > 0) {
                                // Dragging right: left grows, right shrinks
                                // Constraint: right can shrink by at most (rightUni.cols - 1)
                                actualDelta = Math.min(cellDelta, rightUni.cols - 1);
                            } else {
                                // Dragging left: left shrinks, right grows
                                // Constraint: left can shrink by at most (leftUni.cols - 1)
                                actualDelta = Math.max(cellDelta, -(leftUni.cols - 1));
                            }

                            // Apply equal and opposite changes to maintain shared boundary
                            leftUni.cols += actualDelta;
                            rightUni.cols -= actualDelta;

                            dragStartX = mouseX;
                            universeGrid.showCellText = false; // Hide text during adjustment
                            updatePreview();
                        }
                    }
                } else if (draggingBoundary.type === 'horizontal') {
                    const deltaY = mouseY - dragStartY;
                    const cellDelta = Math.round(deltaY / (baseCellSize * scale));

                    if (cellDelta !== 0) {
                        // Get only the two specific universes at this boundary segment
                        const topUni = getUniverse(draggingBoundary.topURow, draggingBoundary.topUCol);
                        const bottomUni = getUniverse(draggingBoundary.bottomURow, draggingBoundary.bottomUCol);

                        // Adjust only these two universes with equal and opposite deltas
                        if (topUni && bottomUni) {
                            // Calculate the actual delta that can be applied (constrained by minimums)
                            let actualDelta;
                            if (cellDelta > 0) {
                                // Dragging down: top grows, bottom shrinks
                                // Constraint: bottom can shrink by at most (bottomUni.rows - 1)
                                actualDelta = Math.min(cellDelta, bottomUni.rows - 1);
                            } else {
                                // Dragging up: top shrinks, bottom grows
                                // Constraint: top can shrink by at most (topUni.rows - 1)
                                actualDelta = Math.max(cellDelta, -(topUni.rows - 1));
                            }

                            // Apply equal and opposite changes to maintain shared boundary
                            topUni.rows += actualDelta;
                            bottomUni.rows -= actualDelta;

                            dragStartY = mouseY;
                            universeGrid.showCellText = false; // Hide text during adjustment
                            updatePreview();
                        }
                    }
                }
            } else if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                panX += deltaX;
                panY += deltaY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updatePreview();
            } else {
                // Update cursor based on position
                const box = detectBoxAtPosition(mouseX, mouseY);
                if (box) {
                    canvas.style.cursor = 'move';
                } else {
                    const boundary = detectBoundaryAtPosition(mouseX, mouseY);
                    if (boundary) {
                        canvas.style.cursor = boundary.type === 'vertical' ? 'ew-resize' : 'ns-resize';
                    } else {
                        canvas.style.cursor = 'grab';
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', function () {
            draggingBoundary = null;
            draggingBox = null;
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function () {
            draggingBoundary = null;
            draggingBox = null;
            isDragging = false;
            canvas.style.cursor = 'grab';

            // Reset crosshair position when mouse leaves canvas
            currentMouseX = -1;
            currentMouseY = -1;
            const showCrosshair = document.getElementById('showCrosshair')?.checked;
            if (showCrosshair) {
                updatePreview();
            }
        });

        // Edit cell fields on double-click
        let editingCell = null;
        let editDialog = null;

        // Parse cell content to extract values
        function parseCellContent(cellValue) {
            let lines = cellValue ? cellValue.split('\n') : [];
            let index = '';
            let universe = '';
            let box = null;  // null = not found, '' = explicitly empty, 'N' = has number
            let note = '';

            // Skip "Box-N" lines at the start (green box markers added during export)
            while (lines.length > 0 && /^Box-\d+$/.test(lines[0].trim())) {
                lines = lines.slice(1);
            }

            // Check if using new & format
            const hasNewFormat = lines.some(line => line.trim().startsWith('&'));

            if (hasNewFormat) {
                // Parse new format: &value, &Uvalue, &Bvalue, &?value
                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('&')) {
                        const content = trimmed.substring(1); // Remove &
                        if (content.startsWith('U')) {
                            universe = content.substring(1);
                        } else if (content.startsWith('B')) {
                            box = content.substring(1);
                        } else if (content.startsWith('?')) {
                            note = content.substring(1);
                        } else {
                            // First & without prefix is the index
                            if (!index) {
                                // Remove dot if present (handle different bullet chars)
                                index = content.replace(/[‚óè‚Ä¢¬∑]\s*/g, '').replace(/\s*[‚óè‚Ä¢¬∑]/g, '').trim();
                            }
                        }
                    }
                });
            } else {
                // Parse old format
                if (lines.length > 0) {
                    // First line might have index or column number
                    const firstLine = lines[0].trim();
                    // Remove dot if present (handle different bullet chars)
                    const cleanFirst = firstLine.replace(/[‚óè‚Ä¢¬∑]\s*/g, '').replace(/\s*[‚óè‚Ä¢¬∑]/g, '').trim();
                    index = cleanFirst;
                }

                if (lines.length > 1) {
                    // Second line has universe and box (e.g., "U6-B10" or "U6-B")
                    const secondLine = lines[1].trim();
                    const universeMatch = secondLine.match(/U(\d+)/);
                    if (universeMatch) {
                        universe = universeMatch[1];
                    }
                    const boxMatch = secondLine.match(/B(\d+)/);
                    if (boxMatch) {
                        box = boxMatch[1];
                    }
                    // Note: "U1-B" without a number means "needs auto-assignment", not "explicitly no box"
                    // Don't set box = '' here - leave it undefined so auto-assignment works
                }

                // Check if B is on its own line (line 3)
                if (lines.length > 2) {
                    const thirdLine = lines[2].trim();
                    const bOnlyMatch = thirdLine.match(/^B(\d+)$/);
                    if (bOnlyMatch && !box) {
                        box = bOnlyMatch[1];
                        // Remaining lines are notes
                        if (lines.length > 3) {
                            note = lines.slice(3).join('\n').trim();
                        }
                    } else {
                        // Third line or beyond might have notes
                        // Fix: Ignore if the line is just "B" (placeholder from export)
                        if (thirdLine === 'B') {
                            note = lines.slice(3).join('\n').trim();
                        } else {
                            note = lines.slice(2).join('\n').trim();
                        }
                    }
                }
            }

            return { index, universe, box, note };
        }

        function createEditDialog(x, y, cellData, cellKey) {
            // Remove existing dialog if any
            if (editDialog) {
                editDialog.remove();
            }

            // Create dialog container
            editDialog = document.createElement('div');
            editDialog.style.position = 'fixed';
            editDialog.style.left = x + 'px';
            editDialog.style.top = y + 'px';
            editDialog.style.width = '200px';
            editDialog.style.padding = '12px';
            editDialog.style.fontSize = '12px';
            editDialog.style.zIndex = '10000';
            editDialog.style.border = '2px solid #667eea';
            editDialog.style.borderRadius = '6px';
            editDialog.style.background = 'rgba(44, 62, 80, 0.95)';
            editDialog.style.backdropFilter = 'blur(10px)';
            editDialog.style.color = 'white';
            editDialog.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';

            // Create form
            const form = document.createElement('div');
            form.style.display = 'flex';
            form.style.flexDirection = 'column';
            form.style.gap = '8px';

            // Title showing cell ID
            const title = document.createElement('div');
            title.style.textAlign = 'center';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '8px';
            title.style.padding = '4px';
            title.style.background = 'rgba(102, 126, 234, 0.3)';
            title.style.borderRadius = '4px';
            // Convert 0-based cellKey to 1-based for display
            let displayKey = 'unknown';
            if (cellKey) {
                const parts = cellKey.split(',');
                if (parts.length === 2) {
                    displayKey = `${parseInt(parts[0]) + 1},${parseInt(parts[1]) + 1}`;
                }
            }
            title.textContent = `Cell: ${displayKey}`;
            form.appendChild(title);

            // Index field (#)
            const indexGroup = document.createElement('div');
            indexGroup.style.display = 'flex';
            indexGroup.style.alignItems = 'center';
            indexGroup.style.gap = '6px';
            const indexLabel = document.createElement('label');
            indexLabel.textContent = '&';
            indexLabel.style.minWidth = '20px';
            indexLabel.style.color = '#aaa';
            const indexSymbol = document.createElement('span');
            indexSymbol.textContent = '#';
            indexSymbol.style.minWidth = '15px';
            indexSymbol.style.color = '#667eea';
            const indexInput = document.createElement('input');
            indexInput.type = 'text';
            indexInput.value = cellData.index || '';
            indexInput.placeholder = '1-20';
            indexInput.style.flex = '1';
            indexInput.style.padding = '4px';
            indexInput.style.border = '1px solid #444';
            indexInput.style.borderRadius = '3px';
            indexInput.style.background = 'rgba(255, 255, 255, 0.1)';
            indexInput.style.color = 'white';
            indexInput.id = 'editIndex';
            indexGroup.appendChild(indexLabel);
            indexGroup.appendChild(indexSymbol);
            indexGroup.appendChild(indexInput);

            // Universe field (U)
            const universeGroup = document.createElement('div');
            universeGroup.style.display = 'flex';
            universeGroup.style.alignItems = 'center';
            universeGroup.style.gap = '6px';
            const universeLabel = document.createElement('label');
            universeLabel.textContent = '&';
            universeLabel.style.minWidth = '20px';
            universeLabel.style.color = '#aaa';
            const universeSymbol = document.createElement('span');
            universeSymbol.textContent = 'U';
            universeSymbol.style.minWidth = '15px';
            universeSymbol.style.color = '#667eea';
            const universeInput = document.createElement('input');
            universeInput.type = 'text';
            universeInput.value = cellData.universe || '';
            universeInput.placeholder = 'Universe';
            universeInput.style.flex = '1';
            universeInput.style.padding = '4px';
            universeInput.style.border = '1px solid #444';
            universeInput.style.borderRadius = '3px';
            universeInput.style.background = 'rgba(255, 255, 255, 0.1)';
            universeInput.style.color = 'white';
            universeInput.id = 'editUniverse';
            universeGroup.appendChild(universeLabel);
            universeGroup.appendChild(universeSymbol);
            universeGroup.appendChild(universeInput);

            // Box field (B)
            const boxGroup = document.createElement('div');
            boxGroup.style.display = 'flex';
            boxGroup.style.alignItems = 'center';
            boxGroup.style.gap = '6px';
            const boxLabel = document.createElement('label');
            boxLabel.textContent = '&';
            boxLabel.style.minWidth = '20px';
            boxLabel.style.color = '#aaa';
            const boxSymbol = document.createElement('span');
            boxSymbol.textContent = 'B';
            boxSymbol.style.minWidth = '15px';
            boxSymbol.style.color = '#667eea';
            const boxInput = document.createElement('input');
            boxInput.type = 'text';
            boxInput.value = cellData.box || '';
            boxInput.placeholder = 'Box';
            boxInput.style.flex = '1';
            boxInput.style.padding = '4px';
            boxInput.style.border = '1px solid #444';
            boxInput.style.borderRadius = '3px';
            boxInput.style.background = 'rgba(255, 255, 255, 0.1)';
            boxInput.style.color = 'white';
            boxInput.id = 'editBox';
            boxGroup.appendChild(boxLabel);
            boxGroup.appendChild(boxSymbol);
            boxGroup.appendChild(boxInput);

            // Note field (?)
            const noteGroup = document.createElement('div');
            noteGroup.style.display = 'flex';
            noteGroup.style.alignItems = 'center';
            noteGroup.style.gap = '6px';
            const noteLabel = document.createElement('label');
            noteLabel.textContent = '&';
            noteLabel.style.minWidth = '20px';
            noteLabel.style.color = '#aaa';
            const noteSymbol = document.createElement('span');
            noteSymbol.textContent = '?';
            noteSymbol.style.minWidth = '15px';
            noteSymbol.style.color = '#667eea';
            const noteInput = document.createElement('input');
            noteInput.type = 'text';
            noteInput.value = cellData.note || '';
            noteInput.placeholder = 'Note';
            noteInput.style.flex = '1';
            noteInput.style.padding = '4px';
            noteInput.style.border = '1px solid #444';
            noteInput.style.borderRadius = '3px';
            noteInput.style.background = 'rgba(255, 255, 255, 0.1)';
            noteInput.style.color = 'white';
            noteInput.id = 'editNote';
            noteGroup.appendChild(noteLabel);
            noteGroup.appendChild(noteSymbol);
            noteGroup.appendChild(noteInput);

            // Buttons
            const buttonGroup = document.createElement('div');
            buttonGroup.style.display = 'flex';
            buttonGroup.style.gap = '6px';
            buttonGroup.style.marginTop = '4px';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.flex = '1';
            saveBtn.style.padding = '6px';
            saveBtn.style.background = '#667eea';
            saveBtn.style.color = 'white';
            saveBtn.style.border = 'none';
            saveBtn.style.borderRadius = '3px';
            saveBtn.style.cursor = 'pointer';
            saveBtn.onclick = finishEditing;

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.flex = '1';
            cancelBtn.style.padding = '6px';
            cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            cancelBtn.style.color = 'white';
            cancelBtn.style.border = '1px solid #444';
            cancelBtn.style.borderRadius = '3px';
            cancelBtn.style.cursor = 'pointer';
            cancelBtn.onclick = cancelEditing;

            buttonGroup.appendChild(saveBtn);
            buttonGroup.appendChild(cancelBtn);

            form.appendChild(indexGroup);
            form.appendChild(universeGroup);
            form.appendChild(boxGroup);
            form.appendChild(noteGroup);
            form.appendChild(buttonGroup);
            editDialog.appendChild(form);

            document.body.appendChild(editDialog);
            indexInput.focus();
            indexInput.select();

            // Handle Escape key
            const escapeHandler = function (e) {
                if (e.key === 'Escape') {
                    cancelEditing();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        // Store custom cell data
        let cellCustomData = new Map(); // key: "row,col", value: {index, universe, box, note}

        // Track manually created points (not from CSV)
        let createdPoints = new Set(); // Set of cellKeys that have manually created points

        // Create a new point for a cell
        function createPointForCell(cellRow, cellCol, cellKey, universeNum) {
            // Check if we are in "Imported Mode" (have imported points OR imported map structure)
            // If so, create a point using direct grid coordinates for stability
            const hasImportedPoints = pointCloudData.some(p => p.isImported) ||
                (customBoxPositions && customBoxPositions.size > 0) ||
                (cellCustomData && cellCustomData.size > 0);

            if (hasImportedPoints) {
                // Create a "Grid Mode" point
                const newPoint = {
                    isImported: true, // Treat as imported so it uses direct cell rendering
                    isCreated: true,  // Mark as created so we know it's not from original file
                    cellKey: cellKey,
                    cellRow: cellRow,
                    cellCol: cellCol,
                    x: cellCol, // Placeholder
                    y: cellRow, // Placeholder
                    leftStagger: true, // Default
                    importedUniverseNum: universeNum // Explicitly assign universe to ensure correct grouping
                };
                pointCloudData.push(newPoint);
                createdPoints.add(cellKey);
                return;
            }

            const baseCellSize = 60;
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);

            // Check if point cloud is loaded (need bounds for coordinate conversion)
            if (!pointCloudLoaded || !pointCloudBounds) {
                console.warn('createPointForCell: No point cloud loaded, cannot create point');
                return;
            }

            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;

            // Determine the stagger pattern by analyzing existing points in the same row
            // Find points in the same grid row to determine if this row is left or right staggered
            let isLeftStagger = true; // Default
            let foundStaggerPattern = false;

            // Look for existing non-created points to determine stagger pattern
            for (const point of pointCloudData) {
                if (point.isCreated) continue; // Skip created points

                // Calculate this point's grid row
                const relativeY = point.y - pointCloudBounds.minY;
                const gridPixelY = relativeY * baseCellSize * pointScale;
                const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                const gridPixelYWithOffset = gridPixelYFlipped + pointOffsetY;
                const pointGridRow = Math.floor(gridPixelYWithOffset / baseCellSize);

                if (pointGridRow === cellRow) {
                    // Found a point in the same row - check its X position within the cell
                    const relativeX = point.x - pointCloudBounds.minX;
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    const pointGridCol = Math.floor(gridPixelXWithOffset / baseCellSize);

                    // Position within cell (0-1 range)
                    const posInCell = (gridPixelXWithOffset / baseCellSize) - pointGridCol;

                    // If position is < 0.5, it's left-staggered; if >= 0.5, it's right-staggered
                    isLeftStagger = posInCell < 0.5;
                    foundStaggerPattern = true;
                    break;
                }
            }

            // If no point found in same row, look at adjacent rows to extrapolate
            if (!foundStaggerPattern) {
                for (const point of pointCloudData) {
                    if (point.isCreated) continue;

                    const relativeY = point.y - pointCloudBounds.minY;
                    const gridPixelY = relativeY * baseCellSize * pointScale;
                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                    const gridPixelYWithOffset = gridPixelYFlipped + pointOffsetY;
                    const pointGridRow = Math.floor(gridPixelYWithOffset / baseCellSize);

                    // Get this point's stagger
                    const relativeX = point.x - pointCloudBounds.minX;
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    const pointGridCol = Math.floor(gridPixelXWithOffset / baseCellSize);
                    const posInCell = (gridPixelXWithOffset / baseCellSize) - pointGridCol;
                    const pointIsLeftStagger = posInCell < 0.5;

                    // Calculate row difference - stagger alternates each row
                    const rowDiff = Math.abs(cellRow - pointGridRow);
                    if (rowDiff % 2 === 0) {
                        // Same stagger pattern
                        isLeftStagger = pointIsLeftStagger;
                    } else {
                        // Opposite stagger pattern
                        isLeftStagger = !pointIsLeftStagger;
                    }
                    foundStaggerPattern = true;
                    break;
                }
            }

            // Calculate target X position with stagger
            // Left stagger: point is left of center (xOffset ~= 0.25)
            // Right stagger: point is right of center (xOffset ~= 0.75)
            const xOffset = isLeftStagger ? 0.25 : 0.75;
            const targetGridPixelX = (cellCol + xOffset) * baseCellSize;
            const targetGridPixelY = (cellRow + 0.5) * baseCellSize;

            // Reverse the transformation to get CSV coordinates
            const gridPixelX = targetGridPixelX - pointOffsetX;
            const relativeX = gridPixelX / (baseCellSize * pointScale);
            const csvX = relativeX + pointCloudBounds.minX;

            const gridPixelYFlipped = targetGridPixelY - pointOffsetY;
            const gridPixelY = (csvHeight * baseCellSize * pointScale) - gridPixelYFlipped;
            const relativeY = gridPixelY / (baseCellSize * pointScale);
            const csvY = relativeY + pointCloudBounds.minY;


            // Add the new point to pointCloudData in CSV coordinate format
            const newPoint = {
                x: csvX,
                y: csvY,
                isCreated: true,
                cellKey: cellKey,
                cellRow: cellRow, // REQUIRED for green box center calculation
                cellCol: cellCol, // REQUIRED for green box center calculation
                importedUniverseNum: universeNum // Explicitly assign universe to ensure correct grouping
            };

            pointCloudData.push(newPoint);
            createdPoints.add(cellKey);

        }

        // Remove ANY point associated with a cell (whether manually created or imported)
        function removePointForCell(cellKey) {
            const [r, c] = cellKey.split(',').map(Number);

            // Need current settings for CSV coordinate reverse-lookup (if CSV points exist)
            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
            const baseCellSize = 60;
            const csvHeight = pointCloudBounds ? (pointCloudBounds.maxY - pointCloudBounds.minY) : 0;

            const initialCount = pointCloudData.length;

            pointCloudData = pointCloudData.filter(p => {
                let pr, pc;
                if (p.isImported || p.isCreated) {
                    pr = p.cellRow;
                    pc = p.cellCol;
                } else if (pointCloudBounds) {
                    // CSV mapping calculation to determine this point's current cell
                    const relativeX = p.x - pointCloudBounds.minX;
                    const relativeY = p.y - pointCloudBounds.minY;
                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelY = relativeY * baseCellSize * pointScale;
                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;
                    pc = Math.floor((gridPixelX + pointOffsetX) / baseCellSize);
                    pr = Math.floor((gridPixelYFlipped + pointOffsetY) / baseCellSize);
                }

                // Keep point if it DOESN'T match our criteria
                const isMatch = (p.cellKey === cellKey) || (pr === r && pc === c);
                return !isMatch;
            });

            const removedCount = initialCount - pointCloudData.length;
            if (removedCount > 0) {
                console.log(`Removed ${removedCount} points for cell ${cellKey}`);
                createdPoints.delete(cellKey);
            }
        }

        function finishEditing() {
            if (!editingCell || !editDialog) return;

            const indexInput = document.getElementById('editIndex');
            const universeInput = document.getElementById('editUniverse');
            const boxInput = document.getElementById('editBox');
            const noteInput = document.getElementById('editNote');

            if (!indexInput || !universeInput || !boxInput || !noteInput) {
                cancelEditing();
                return;
            }

            // Use the actual cell key (based on point position) if available
            const cellKey = editingCell.actualCellKey || `${editingCell.cellRow},${editingCell.cellCol}`;


            // Get values
            const index = indexInput.value.trim();
            const universe = universeInput.value.trim();
            const box = boxInput.value.trim();
            const note = noteInput.value.trim();

            // Store custom data if any field has a value
            // If B is empty but other fields have values, we store box: '' to mark it as "explicitly no box"
            if (index || universe || box || note) {
                // Store custom data - include box even if empty string to mark it as "explicitly no box"
                cellCustomData.set(cellKey, { index, universe, box: box, note });

                // Update box number mapping if box is set
                if (box) {
                    // Remove B/b prefix and whitespace
                    const boxNum = parseInt(box.toString().replace(/^[Bb]\s*/, '').trim());
                    if (!isNaN(boxNum) && boxNum > 0) {
                        cellToBoxNumber.set(cellKey, boxNum);

                        // If this cell had no point and a B number was added, CREATE a new point
                        if (!editingCell.hasPoint) {
                            // Pass the universe number from the editing cell context to ensure correct grouping
                            createPointForCell(editingCell.cellRow, editingCell.cellCol, cellKey, editingCell.universeNum);
                        }
                    } else {
                        // Invalid box number, clear association and remove point
                        cellToBoxNumber.delete(cellKey);
                        removePointForCell(cellKey);
                    }
                } else {
                    // B is explicitly empty - clear box assignment and don't auto-assign
                    cellToBoxNumber.delete(cellKey);

                    // If the cell had a point that was CREATED (not from CSV), remove it
                    removePointForCell(cellKey);
                }
            } else {
                // Clear all custom data if all fields are empty
                cellCustomData.delete(cellKey);
                cellToBoxNumber.delete(cellKey);

                // Remove any created point
                removePointForCell(cellKey);
            }

            // Recalculate cable groups to update green dot positions and groupings
            if (pointCloudLoaded && pointCloudData.length > 0) {
                calculateCableGroups();
            }

            // Redraw to show updated cell content
            updatePreview();

            cancelEditing();
        }

        function cancelEditing() {
            if (editDialog) {
                editDialog.remove();
                editDialog = null;
            }
            editingCell = null;
        }

        // Detect which cell was clicked
        function getCellAtPosition(mouseX, mouseY) {
            const canvas = document.getElementById('gridCanvas');
            const baseCellSize = 60;
            const totalCols = getTotalCols();
            const totalRows = getTotalRows();
            const gridPixelWidth = totalCols * baseCellSize;
            const gridPixelHeight = totalRows * baseCellSize;

            const availableWidth = canvas.width * 0.9;
            const availableHeight = canvas.height * 0.9;
            const scaleX = availableWidth / gridPixelWidth;
            const scaleY = availableHeight / gridPixelHeight;
            const baseScale = Math.min(scaleX, scaleY);
            const scale = baseScale * zoom;

            const gridWidth = gridPixelWidth * scale;
            const gridHeight = gridPixelHeight * scale;
            const baseOffsetX = (canvas.width - gridWidth) / 2;
            const baseOffsetY = (canvas.height - gridHeight) / 2;
            const offsetX = baseOffsetX + panX;
            const offsetY = baseOffsetY + panY;

            // Convert mouse position to grid coordinates
            const gridX = (mouseX - offsetX) / scale;
            const gridY = (mouseY - offsetY) / scale;

            const cellCol = Math.floor(gridX / baseCellSize);
            const cellRow = Math.floor(gridY / baseCellSize);


            if (cellCol >= 0 && cellCol < totalCols && cellRow >= 0 && cellRow < totalRows) {
                const cellUniverse = getCellUniverse(cellCol, cellRow);
                if (cellUniverse) {
                    return {
                        cellCol: cellCol,
                        cellRow: cellRow,
                        universeNum: cellUniverse.universeNum,
                        screenX: offsetX + (cellCol * baseCellSize * scale),
                        screenY: offsetY + (cellRow * baseCellSize * scale)
                    };
                }
            }
            return null;
        }

        // Find the point that is visually closest to the clicked screen position
        // Returns { pointIndex, cellKey } or null if no point near the click
        function findPointAtScreenPosition(screenX, screenY, gridOffsetX, gridOffsetY, gridScale) {
            if (!pointCloudLoaded || pointCloudData.length === 0) {
                return null;
            }

            const pointScale = parseFloat(document.getElementById('pointScale')?.value || 1);
            const pointOffsetX = parseFloat(document.getElementById('pointOffsetX')?.value || 17);
            const pointOffsetY = parseFloat(document.getElementById('pointOffsetY')?.value || 30);
            const baseCellSize = 60;
            const csvWidth = pointCloudBounds.maxX - pointCloudBounds.minX;
            const csvHeight = pointCloudBounds.maxY - pointCloudBounds.minY;

            // Find the point closest to the clicked screen position
            let closestPoint = null;
            let closestDistance = Infinity;
            const maxDistance = baseCellSize * gridScale; // Max distance = one cell size in screen pixels

            for (let i = 0; i < pointCloudData.length; i++) {
                const point = pointCloudData[i];
                let px, py;

                if (point.isImported) {
                    // Calculation for imported points (matches drawPointCloud)
                    const screenXPos = gridOffsetX + (point.cellCol * baseCellSize * gridScale);
                    const screenYPos = gridOffsetY + (point.cellRow * baseCellSize * gridScale);

                    // Center of cell + stagger
                    px = screenXPos + (baseCellSize * 0.5 * gridScale) + (point.xStagger * baseCellSize * gridScale);
                    py = screenYPos + (baseCellSize * 0.5 * gridScale);
                } else {
                    // Calculation for CSV points
                    const relativeX = point.x - pointCloudBounds.minX;
                    const relativeY = point.y - pointCloudBounds.minY;

                    const gridPixelX = relativeX * baseCellSize * pointScale;
                    const gridPixelY = relativeY * baseCellSize * pointScale;
                    const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                    const gridPixelXWithOffset = gridPixelX + pointOffsetX;
                    const gridPixelYFlippedWithOffset = gridPixelYFlipped + pointOffsetY;

                    // Calculate screen position
                    px = gridOffsetX + (gridPixelXWithOffset * gridScale);
                    py = gridOffsetY + (gridPixelYFlippedWithOffset * gridScale);
                }

                // Distance from clicked position to this point's screen position
                const dist = Math.sqrt(Math.pow(px - screenX, 2) + Math.pow(py - screenY, 2));

                if (dist < closestDistance && dist < maxDistance) {
                    closestDistance = dist;

                    // Use the stored cell key or calculate it
                    let cellKey;
                    if (point.cellKey) {
                        cellKey = point.cellKey;
                    } else {
                        // Calculate for CSV points
                        const relativeX = point.x - pointCloudBounds.minX;
                        const relativeY = point.y - pointCloudBounds.minY;
                        const gridPixelX = relativeX * baseCellSize * pointScale;
                        const gridPixelY = relativeY * baseCellSize * pointScale;
                        const gridPixelYFlipped = (csvHeight * baseCellSize * pointScale) - gridPixelY;

                        const pr = Math.floor((gridPixelYFlipped + pointOffsetY) / baseCellSize);
                        const pc = Math.floor((gridPixelX + pointOffsetX) / baseCellSize);
                        cellKey = `${pr},${pc}`;
                    }

                    closestPoint = {
                        pointIndex: i,
                        cellKey: cellKey,
                        screenX: px,
                        screenY: py,
                        distance: dist
                    };
                }
            }

            if (closestPoint) {
                return {
                    pointIndex: closestPoint.pointIndex,
                    cellKey: closestPoint.cellKey
                };
            }

            return null;
        }

        // Legacy function - kept for compatibility
        function findPointInCell(cellRow, cellCol) {
            return null;
        }

        canvas.addEventListener('dblclick', function (e) {
            e.preventDefault();
            e.stopPropagation();

            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution
            const cssToCanvasX = canvas.width / rect.width;
            const cssToCanvasY = canvas.height / rect.height;
            const rawMouseX = e.clientX - rect.left;
            const rawMouseY = e.clientY - rect.top;
            const mouseX = rawMouseX * cssToCanvasX;
            const mouseY = rawMouseY * cssToCanvasY;


            const cell = getCellAtPosition(mouseX, mouseY);
            if (cell) {
                editingCell = cell;

                // Calculate the grid transform parameters (same as in drawGridPreview)
                const baseCellSize = 60;
                const totalCols = getTotalCols();
                const totalRows = getTotalRows();
                const gridPixelWidth = totalCols * baseCellSize;
                const gridPixelHeight = totalRows * baseCellSize;
                const availableWidth = canvas.width * 0.9;
                const availableHeight = canvas.height * 0.9;
                const scaleX = availableWidth / gridPixelWidth;
                const scaleY = availableHeight / gridPixelHeight;
                const baseScale = Math.min(scaleX, scaleY);
                const currentScale = baseScale * zoom;

                const gridWidth = gridPixelWidth * currentScale;
                const gridHeight = gridPixelHeight * currentScale;
                const baseOffsetX = (canvas.width - gridWidth) / 2;
                const baseOffsetY = (canvas.height - gridHeight) / 2;
                const gridOffsetX = baseOffsetX + panX;
                const gridOffsetY = baseOffsetY + panY;

                // Find point using screen coordinates (accounts for zoom, pan, and point transform)
                const pointInfo = findPointAtScreenPosition(mouseX, mouseY, gridOffsetX, gridOffsetY, currentScale);

                // Use the clicked cell's key (NOT the point's key - we want to edit the cell we clicked on)
                const clickedCellKey = `${cell.cellRow},${cell.cellCol}`;
                const cellKey = clickedCellKey;

                // Store the actual cell key for use in finishEditing
                editingCell.actualCellKey = cellKey;
                editingCell.hasPoint = pointInfo !== null && pointInfo.cellKey === clickedCellKey;

                let cellData = cellCustomData.get(cellKey);

                // If no custom data, parse from current cell content or use defaults
                if (!cellData) {
                    // Get the cell's universe info
                    const cellUniverse = getCellUniverse(cell.cellCol, cell.cellRow);
                    if (cellUniverse) {
                        const colInUniverse = cellUniverse.cellInUniverseCol;
                        const rowInUniverse = cellUniverse.cellInUniverseRow;
                        const universeNum = cellUniverse.universeNum;
                        const currentBoxNum = cellToBoxNumber.get(cellKey);

                        // Get the current cell label to parse the first line (index)
                        const currentLabel = generateCellLabel(rowInUniverse + 1, colInUniverse, universeNum, currentBoxNum, cell.cellRow, cell.cellCol);
                        const lines = currentLabel.split('\n');
                        const firstLine = lines[0] ? lines[0].trim() : '';
                        // Remove dot if present
                        const indexValue = firstLine.replace(/‚óè\s*/g, '').replace(/\s*‚óè/g, '').trim();

                        // Try to parse existing cell format
                        cellData = {
                            index: indexValue || (colInUniverse + 1).toString(), // Use first line or fallback to column
                            universe: universeNum.toString(),
                            box: currentBoxNum ? currentBoxNum.toString() : '',
                            note: ''
                        };
                    } else {
                        cellData = { index: '', universe: '', box: '', note: '' };
                    }
                }

                // Position dialog near the cell (reuse grid transform values from above)
                const cellScreenX = gridOffsetX + (cell.cellCol * baseCellSize * currentScale);
                const cellScreenY = gridOffsetY + (cell.cellRow * baseCellSize * currentScale);

                // Position dialog at center of cell, offset to avoid covering it
                const dialogX = rect.left + cellScreenX + (baseCellSize * currentScale) / 2 - 100;
                const dialogY = rect.top + cellScreenY + (baseCellSize * currentScale) / 2 - 100;

                createEditDialog(dialogX, dialogY, cellData, cellKey);
            }
        });
    </script>
</body>

</html>